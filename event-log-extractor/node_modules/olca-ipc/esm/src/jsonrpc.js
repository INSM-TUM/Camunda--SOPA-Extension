import * as o from "./schema.js";
import * as protocol from "./protocol.js";
import * as util from "./util.js";
export class IpcClient {
    constructor(url) {
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: url
        });
        Object.defineProperty(this, "_id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    static on(portOrEndpoint) {
        const url = typeof portOrEndpoint === "number"
            ? `http://localhost:${portOrEndpoint}`
            : portOrEndpoint;
        return new IpcClient(url);
    }
    async get(refType, q) {
        const conf = util.EntityQuery.of(q);
        if (conf.isEmpty()) {
            throw Error("An ID or name bust be provided");
        }
        const resp = await this._call("data/get", conf.toDict(refType), util.fromDictOf(refType));
        return resp.orElse(null);
    }
    async getAll(refType) {
        const fn = util.fromDictOf(refType);
        const resp = await this._callEach("data/get/all", { "@type": refType }, fn);
        return resp.orElseThrow();
    }
    async getDescriptors(refType) {
        const resp = await this._callEach("data/get/descriptors", { "@type": refType }, o.Ref.fromDict);
        return resp.orElseThrow();
    }
    async getDescriptor(refType, q) {
        const conf = util.EntityQuery.of(q);
        if (conf.isEmpty()) {
            throw Error("An ID or name bust be provided");
        }
        const resp = await this._call("data/get/descriptor", conf.toDict(refType), o.Ref.fromDict);
        return resp.orElse(null);
    }
    async getProviders(flow) {
        const params = flow ? flow.toDict() : {};
        const resp = await this._callEach("data/get/providers", params, o.TechFlow.fromDict);
        return resp.orElseThrow();
    }
    async getParameters(type, id) {
        const params = {
            "@type": type,
            "@id": id,
        };
        const fn = type === o.RefType.Process || type === o.RefType.ImpactCategory
            ? o.Parameter.fromDict
            : o.ParameterRedef.fromDict;
        const resp = await this._callEach("data/get/parameters", params, fn);
        return resp.orElse([]);
    }
    async put(model) {
        const resp = await this._call("data/put", model.toDict(), o.Ref.fromDict);
        return resp.orElseThrow();
    }
    async createProductSystem(process, config) {
        const ref = process instanceof o.Process ? process.toRef() : process;
        const conf = config ? config : o.LinkingConfig.of({
            preferUnitProcesses: false,
            providerLinking: o.ProviderLinking.PREFER_DEFAULTS,
        });
        const params = {
            "process": ref.toDict(),
            "config": conf.toDict(),
        };
        const resp = await this._call("data/create/system", params, o.Ref.fromDict);
        return resp.orElseThrow();
    }
    async delete(model) {
        if (!model) {
            return null;
        }
        const ref = model instanceof o.Ref ? model : model.toRef();
        const resp = await this._call("data/delete", ref.toDict(), o.Ref.fromDict);
        return resp.orElse(null);
    }
    async calculate(setup) {
        const resp = await this._call("result/calculate", setup.toDict(), o.ResultState.fromDict);
        const state = resp.orElseThrow();
        return new IpcResult(this, state);
    }
    async simulate(setup) {
        const resp = await this._call("result/simulate", setup.toDict(), o.ResultState.fromDict);
        const state = resp.orElseThrow();
        return new IpcResult(this, state);
    }
    async _callEach(method, params, fn) {
        const resp = await this._call(method, params, (x) => x);
        if (resp.isError() || resp.isEmpty()) {
            return resp;
        }
        const raw = resp.value;
        if (!Array.isArray(raw)) {
            return protocol.Response.error("returned value is not an array");
        }
        const res = [];
        for (const e of raw) {
            const t = fn(e);
            if (t) {
                res.push(t);
            }
        }
        return protocol.Response.of(res);
    }
    async _call(method, params, fn) {
        const id = ++this._id;
        const resp = await (await fetch(this.url, {
            method: "POST",
            body: JSON.stringify({ jsonrpc: "2.0", id, method, params }),
        })).json();
        const err = resp["error"];
        if (err) {
            return protocol.Response.error(`${err.code}: ${err.message}`);
        }
        const result = resp["result"];
        if (!result) {
            return protocol.Response.empty();
        }
        const val = fn(result);
        if (val == null || val === undefined) {
            return protocol.Response.empty();
        }
        return protocol.Response.of(val);
    }
}
export class IpcResult {
    constructor(client, state) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = state.id || "";
        if (state.error) {
            this.error = state;
        }
    }
    async getState() {
        return await this.nextState("result/state");
    }
    async simulateNext() {
        return await this.nextState("result/simulate/next");
    }
    async dispose() {
        await this.client._call("result/dispose", { "@id": this.id }, (x) => x);
    }
    async nextState(method) {
        if (this.error) {
            return this.error;
        }
        const resp = await this.client._call(method, { "@id": this.id }, o.ResultState.fromDict);
        if (resp.isError()) {
            this.error = o.ResultState.of({
                id: this.id,
                error: resp.error,
            });
            return this.error;
        }
        if (resp.isEmpty()) {
            this.error = o.ResultState.of({
                id: this.id,
                error: "failed to get result state",
            });
            return this.error;
        }
        const next = resp.value;
        if (next.error) {
            this.error = next;
        }
        else if (this.error) {
            delete this.error;
        }
        return next;
    }
    async untilReady(pollTime = 1000) {
        let state;
        while (!(state = await this.getState()).isReady) {
            if (state.error) {
                return state;
            }
            await new Promise((r) => setTimeout(r, pollTime));
        }
        return state;
    }
    //#region Result elements
    async getDemand() {
        const resp = await this.client._call("result/demand", { "@id": this.id }, o.TechFlowValue.fromDict);
        return resp.orElse(o.TechFlowValue.of({ amount: 0 }));
    }
    async getTechFlows() {
        const resp = await this.client._callEach("result/tech-flows", {
            "@id": this.id,
        }, o.TechFlow.fromDict);
        return resp.orElse([]);
    }
    async getEnviFlows() {
        const resp = await this.client._callEach("result/envi-flows", {
            "@id": this.id,
        }, o.EnviFlow.fromDict);
        return resp.orElse([]);
    }
    async getImpactCategories() {
        const resp = await this.client._callEach("result/impact-categories", {
            "@id": this.id,
        }, o.Ref.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Technosphere flows
    async getScalingFactors() {
        const resp = await this.client._callEach("result/scaling-factors", {
            "@id": this.id,
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalRequirements() {
        const resp = await this.client._callEach("result/total-requirements", {
            "@id": this.id,
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalRequirementsOf(techFlow) {
        const resp = await this.client._call("result/total-requirements-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.TechFlowValue.fromDict);
        return resp.orElse(o.TechFlowValue.of({ amount: 0 }));
    }
    async getScaledTechFlowsOf(techFlow) {
        const resp = await this.client._callEach("result/scaled-tech-flows-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getUnscaledTechFlowsOf(techFlow) {
        const resp = await this.client._callEach("result/unscaled-tech-flows-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Inventory results
    async getTotalFlows() {
        const resp = await this.client._callEach("result/total-flows", {
            "@id": this.id,
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalFlowValueOf(enviFlow) {
        const resp = await this.client._call("result/total-flow-value-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getFlowContributionsOf(enviFlow) {
        const resp = await this.client._callEach("result/flow-contributions-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectInterventionsOf(techFlow) {
        const resp = await this.client._callEach("result/direct-interventions-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectInterventionOf(enviFlow, techFlow) {
        const resp = await this.client._call("result/direct-intervention-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getFlowIntensitiesOf(techFlow) {
        const resp = await this.client._callEach("result/flow-intensities-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getFlowIntensityOf(enviFlow, techFlow) {
        const resp = await this.client._call("result/flow-intensity-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getTotalInterventionsOf(techFlow) {
        const resp = await this.client._callEach("result/total-interventions-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalInterventionOf(enviFlow, techFlow) {
        const resp = await this.client._call("result/total-intervention-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getUpstreamInterventionsOf(enviFlow, path) {
        const resp = await this.client._callEach("result/upstream-interventions-of", {
            "@id": this.id,
            "enviFlow": enviFlow.toDict(),
            "path": pathOf(path),
        }, o.UpstreamNode.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Impact assessment results
    async getTotalImpacts() {
        const resp = await this.client._callEach("result/total-impacts", {
            "@id": this.id,
        }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getNormalizedImpacts() {
        const resp = await this.client._callEach("result/total-impacts/normalized", { "@id": this.id }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getWeightedImpacts() {
        const resp = await this.client._callEach("result/total-impacts/weighted", {
            "@id": this.id,
        }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalImpactValueOf(impactCategory) {
        const resp = await this.client._call("result/total-impact-value-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactContributionsOf(impactCategory) {
        const resp = await this.client._callEach("result/impact-contributions-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectImpactsOf(techFlow) {
        const resp = await this.client._callEach("result/direct-impacts-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectImpactOf(impactCategory, techFlow) {
        const resp = await this.client._call("result/direct-impact-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactIntensitiesOf(techFlow) {
        const resp = await this.client._callEach("result/impact-intensities-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getImpactIntensityOf(impactCategory, techFlow) {
        const resp = await this.client._call("result/impact-intensity-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getTotalImpactsOf(techFlow) {
        const resp = await this.client._callEach("result/total-impacts-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalImpactOf(impactCategory, techFlow) {
        const resp = await this.client._call("result/total-impact-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "techFlow": techFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactFactorsOf(impactCategory) {
        const resp = await this.client._callEach("result/impact-factors-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getImpactFactorOf(impactCategory, enviFlow) {
        const resp = await this.client._call("result/impact-factor-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "enviFlow": enviFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getFlowImpactsOf(impactCategory) {
        const resp = await this.client._callEach("result/flow-impacts-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
        }, o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getFlowImpactOf(impactCategory, enviFlow) {
        const resp = await this.client._call("result/flow-impact-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "enviFlow": enviFlow.toDict(),
        }, o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getUpstreamImpactsOf(impactCategory, path) {
        const resp = await this.client._callEach("result/upstream-impacts-of", {
            "@id": this.id,
            "impactCategory": impactCategory.toDict(),
            "path": pathOf(path),
        }, o.UpstreamNode.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Cost results
    async getTotalCosts() {
        const resp = await this.client._call("result/total-costs", {
            "@id": this.id,
        }, o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getCostContributions() {
        const resp = await this.client._callEach("result/cost-contributions", {
            "@id": this.id,
        }, o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectCostsOf(techFlow) {
        const resp = await this.client._call("result/direct-costs-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getCostIntensitiesOf(techFlow) {
        const resp = await this.client._call("result/cost-intensities-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getTotalCostsOf(techFlow) {
        const resp = await this.client._call("result/total-costs-of", {
            "@id": this.id,
            "techFlow": techFlow.toDict(),
        }, o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getUpstreamCostsOf(path) {
        const resp = await this.client._callEach("result/upstream-costs-of", {
            "@id": this.id,
            "path": pathOf(path),
        }, o.UpstreamNode.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    async getSankeyGraph(config) {
        const resp = await this.client._call("result/sankey", {
            "@id": this.id,
            "config": config.toDict(),
        }, o.SankeyGraph.fromDict);
        return resp.orElseThrow();
    }
}
function pathOf(path) {
    if (!path || path.length === 0) {
        return null;
    }
    let p = "";
    for (const techFlow of path) {
        const providerId = techFlow.provider?.id;
        const flowId = techFlow.flow?.id;
        const next = `${providerId}::${flowId}`;
        p += p.length === 0 ? next : "/" + next;
    }
    return p;
}
