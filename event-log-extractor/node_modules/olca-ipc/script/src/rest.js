"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestResult = exports.RestClient = void 0;
const o = __importStar(require("./schema.js"));
const protocol = __importStar(require("./protocol.js"));
const util = __importStar(require("./util.js"));
class RestClient {
    constructor(base) {
        Object.defineProperty(this, "base", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: base
        });
    }
    static on(portOrEndpoint) {
        let base;
        if (typeof portOrEndpoint === "number") {
            base = `http://localhost:${portOrEndpoint}/`;
        }
        else if (typeof portOrEndpoint === "string") {
            base = !portOrEndpoint.endsWith("/")
                ? portOrEndpoint + "/"
                : portOrEndpoint;
        }
        else {
            throw Error("needs a port number or URL but got: " + portOrEndpoint);
        }
        return new RestClient(base);
    }
    async get(refType, q) {
        const conf = util.EntityQuery.of(q);
        if (conf.isEmpty()) {
            throw Error("An ID or name bust be provided");
        }
        const prefix = `data/${pathOf(refType)}`;
        const path = conf.hasName()
            ? `${prefix}/name/${conf.uriName()}`
            : `${prefix}/${conf.id}`;
        const resp = await this._call(path, util.fromDictOf(refType));
        return resp.orElse(null);
    }
    async getAll(refType) {
        const resp = await this._callEach(`data/${pathOf(refType)}/all`, util.fromDictOf(refType));
        return resp.orElse([]);
    }
    async getDescriptors(refType) {
        const resp = await this._callEach(`data/${pathOf(refType)}`, o.Ref.fromDict);
        return resp.orElse([]);
    }
    async getDescriptor(refType, q) {
        const conf = util.EntityQuery.of(q);
        if (conf.isEmpty()) {
            throw Error("An ID or name bust be provided");
        }
        const prefix = `data/${pathOf(refType)}`;
        const path = conf.hasId()
            ? `${prefix}/${conf.id}/info`
            : `${prefix}/name/${conf.uriName()}/info`;
        const resp = await this._call(path, o.Ref.fromDict);
        return resp.orElse(null);
    }
    async getProviders(flow) {
        const path = flow?.id ? `data/providers/${flow.id}` : `data/providers`;
        const resp = await this._callEach(path, o.TechFlow.fromDict);
        return resp.orElse([]);
    }
    async getParameters(type, id) {
        const path = `data/${pathOf(type)}/${id}/parameters`;
        const fn = type === o.RefType.Process || type === o.RefType.ImpactCategory
            ? o.Parameter.fromDict
            : o.ParameterRedef.fromDict;
        const resp = await this._callEach(path, fn);
        return resp.orElse([]);
    }
    async put(model) {
        const dict = model.toDict();
        const type = dict["@type"];
        const resp = await this._call(`data/${pathOf(type)}`, o.Ref.fromDict, "PUT", dict);
        return resp.orElseThrow();
    }
    async createProductSystem(process, config) {
        const ref = process instanceof o.Process ? process.toRef() : process;
        const conf = config ? config : o.LinkingConfig.of({
            preferUnitProcesses: false,
            providerLinking: o.ProviderLinking.PREFER_DEFAULTS,
        });
        const params = {
            "process": ref.toDict(),
            "config": conf.toDict(),
        };
        const resp = await this._call("data/create-system", o.Ref.fromDict, "POST", params);
        return resp.orElseThrow();
    }
    async delete(model) {
        if (!model) {
            return null;
        }
        const ref = model instanceof o.Ref ? model : model.toRef();
        const path = `data/${pathOf(ref.refType)}/${ref.id}`;
        const resp = await this._call(path, o.Ref.fromDict, "DELETE");
        return resp.orElse(null);
    }
    async calculate(setup) {
        const resp = await this._call("result/calculate", o.ResultState.fromDict, "POST", setup.toDict());
        const state = resp.orElseThrow();
        return new RestResult(this, state);
    }
    async simulate(setup) {
        const resp = await this._call("result/simulate", o.ResultState.fromDict, "POST", setup.toDict());
        const state = resp.orElseThrow();
        return new RestResult(this, state);
    }
    async _callEach(path, fn, method = "GET", body) {
        const resp = await this._call(path, (x) => x, method, body);
        if (resp.isError() || resp.isEmpty()) {
            return resp;
        }
        const array = resp.value;
        if (!Array.isArray(array)) {
            return protocol.Response.empty();
        }
        const res = [];
        for (const i of array) {
            const next = fn(i);
            if (next) {
                res.push(next);
            }
        }
        return protocol.Response.of(res);
    }
    async _call(path, fn, method = "GET", body) {
        const url = `${this.base}${path}`;
        const config = {
            method,
            headers: {
                "Accept": "application/json",
            },
        };
        if (body) {
            config.headers["Content-Type"] = "application/json";
            config.body = JSON.stringify(body);
        }
        const resp = await fetch(url, config);
        if (!ok(resp.status)) {
            const message = await resp.text();
            return protocol.Response.error(message);
        }
        const json = await resp.json();
        if (!json) {
            return protocol.Response.empty();
        }
        const val = fn(json);
        return val ? protocol.Response.of(val) : protocol.Response.empty();
    }
}
exports.RestClient = RestClient;
class RestResult {
    constructor(client, state) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: client
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.id = state.id || "";
        if (state.error) {
            this.error = state;
        }
    }
    async getState() {
        return await this.nextState("state");
    }
    async simulateNext() {
        return await this.nextState("simulate/next", "POST");
    }
    async dispose() {
        await this.client._call(this.path("dispose"), (x) => x, "POST");
    }
    async nextState(path, method = "GET") {
        if (this.error) {
            return this.error;
        }
        const resp = await this.client._call(this.path(path), o.ResultState.fromDict, method);
        if (resp.isError()) {
            this.error = o.ResultState.of({
                id: this.id,
                error: resp.error,
            });
            return this.error;
        }
        if (resp.isEmpty()) {
            this.error = o.ResultState.of({
                id: this.id,
                error: "failed to get result state",
            });
            return this.error;
        }
        const next = resp.value;
        if (next.error) {
            this.error = next;
        }
        else if (this.error) {
            delete this.error;
        }
        return next;
    }
    async untilReady(pollTime = 1000) {
        let state;
        while (!(state = await this.getState()).isReady) {
            if (state.error) {
                return state;
            }
            await new Promise((r) => setTimeout(r, pollTime));
        }
        return state;
    }
    path(segments) {
        let path = `result/${this.id}`;
        if (typeof segments === "string") {
            path += "/" + segments;
        }
        else if (Array.isArray(segments)) {
            for (const seg of segments) {
                path += "/" + seg;
            }
        }
        return path;
    }
    //#region Result elements
    async getDemand() {
        const resp = await this.client._call(this.path("demand"), o.TechFlowValue.fromDict);
        return resp.orElse(o.TechFlowValue.of({ amount: 0 }));
    }
    async getTechFlows() {
        const resp = await this.client._callEach(this.path("tech-flows"), o.TechFlow.fromDict);
        return resp.orElse([]);
    }
    async getEnviFlows() {
        const resp = await this.client._callEach(this.path("envi-flows"), o.EnviFlow.fromDict);
        return resp.orElse([]);
    }
    async getImpactCategories() {
        const resp = await this.client._callEach(this.path("impact-categories"), o.Ref.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Technosphere flows
    async getScalingFactors() {
        const resp = await this.client._callEach(this.path("scaling-factors"), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalRequirements() {
        const resp = await this.client._callEach(this.path("total-requirements"), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalRequirementsOf(techFlow) {
        const resp = await this.client._call(this.path(["total-requirements-of", techIdOf(techFlow)]), o.TechFlowValue.fromDict);
        return resp.orElse(o.TechFlowValue.of({ amount: 0 }));
    }
    async getScaledTechFlowsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["scaled-tech-flows-of", techIdOf(techFlow)]), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getUnscaledTechFlowsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["unscaled-tech-flows-of", techIdOf(techFlow)]), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    //#endregion
    //#region Inventory results
    async getTotalFlows() {
        const resp = await this.client._callEach(this.path("total-flows"), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalFlowValueOf(enviFlow) {
        const resp = await this.client._call(this.path(["total-flow-value-of", enviIdOf(enviFlow)]), o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getFlowContributionsOf(enviFlow) {
        const resp = await this.client._callEach(this.path(["flow-contributions-of", enviIdOf(enviFlow)]), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectInterventionsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["direct-interventions-of", techIdOf(techFlow)]), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectInterventionOf(enviFlow, techFlow) {
        const resp = await this.client._call(this.path([
            "direct-intervention-of",
            enviIdOf(enviFlow),
            techIdOf(techFlow),
        ]), o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getFlowIntensitiesOf(techFlow) {
        const resp = await this.client._callEach(this.path(["flow-intensities-of", techIdOf(techFlow)]), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getFlowIntensityOf(enviFlow, techFlow) {
        const resp = await this.client._call(this.path(["flow-intensity-of", enviIdOf(enviFlow), techIdOf(techFlow)]), o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getTotalInterventionsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["total-interventions-of", techIdOf(techFlow)]), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalInterventionOf(enviFlow, techFlow) {
        const resp = await this.client._call(this.path([
            "total-intervention-of",
            enviIdOf(enviFlow),
            techIdOf(techFlow),
        ]), o.EnviFlowValue.fromDict);
        return resp.orElse(o.EnviFlowValue.of({ amount: 0 }));
    }
    async getUpstreamInterventionsOf(enviFlow, path) {
        const resp = await this.client._callEach(this.path([
            "upstream-interventions-of",
            enviIdOf(enviFlow),
        ]), o.UpstreamNode.fromDict, "POST", upstreamPathOf(path));
        return resp.orElse([]);
    }
    //#endregion
    //#region Impact assessment results
    async getTotalImpacts() {
        const resp = await this.client._callEach(this.path("total-impacts"), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getNormalizedImpacts() {
        const resp = await this.client._callEach(this.path("total-impacts/normalized"), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getWeightedImpacts() {
        const resp = await this.client._callEach(this.path("total-impacts/weighted"), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalImpactValueOf(impactCategory) {
        const resp = await this.client._call(this.path(["total-impact-value-of", impactCategory.id]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactContributionsOf(impactCategory) {
        const resp = await this.client._callEach(this.path(["impact-contributions-of", impactCategory.id]), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectImpactsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["direct-impacts-of", techIdOf(techFlow)]), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectImpactOf(impactCategory, techFlow) {
        const resp = await this.client._call(this.path(["direct-impact-of", impactCategory.id, techIdOf(techFlow)]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactIntensitiesOf(techFlow) {
        const resp = await this.client._callEach(this.path(["impact-intensities-of", techIdOf(techFlow)]), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getImpactIntensityOf(impactCategory, techFlow) {
        const resp = await this.client._call(this.path([
            "impact-intensity-of",
            impactCategory.id,
            techIdOf(techFlow),
        ]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getTotalImpactsOf(techFlow) {
        const resp = await this.client._callEach(this.path(["total-impacts-of", techIdOf(techFlow)]), o.ImpactValue.fromDict);
        return resp.orElse([]);
    }
    async getTotalImpactOf(impactCategory, techFlow) {
        const resp = await this.client._call(this.path(["total-impact-of", impactCategory.id, techIdOf(techFlow)]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getImpactFactorsOf(impactCategory) {
        const resp = await this.client._callEach(this.path(["impact-factors-of", impactCategory.id]), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getImpactFactorOf(impactCategory, enviFlow) {
        const resp = await this.client._call(this.path(["impact-factor-of", impactCategory.id, enviIdOf(enviFlow)]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getFlowImpactsOf(impactCategory) {
        const resp = await this.client._callEach(this.path(["flow-impacts-of", impactCategory.id]), o.EnviFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getFlowImpactOf(impactCategory, enviFlow) {
        const resp = await this.client._call(this.path(["flow-impact-of", impactCategory.id, enviIdOf(enviFlow)]), o.ImpactValue.fromDict);
        return resp.orElse(o.ImpactValue.of({ amount: 0 }));
    }
    async getUpstreamImpactsOf(impactCategory, path) {
        const resp = await this.client._callEach(this.path([
            "upstream-impacts-of",
            impactCategory.id,
        ]), o.UpstreamNode.fromDict, "POST", upstreamPathOf(path));
        return resp.orElse([]);
    }
    //#endregion
    //#region Cost results
    async getTotalCosts() {
        const resp = await this.client._call(this.path("total-costs"), o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getCostContributions() {
        const resp = await this.client._callEach(this.path("cost-contributions"), o.TechFlowValue.fromDict);
        return resp.orElse([]);
    }
    async getDirectCostsOf(techFlow) {
        const resp = await this.client._call(this.path(["direct-costs-of", techIdOf(techFlow)]), o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getCostIntensitiesOf(techFlow) {
        const resp = await this.client._call(this.path(["cost-intensities-of", techIdOf(techFlow)]), o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getTotalCostsOf(techFlow) {
        const resp = await this.client._call(this.path(["total-costs-of", techIdOf(techFlow)]), o.CostValue.fromDict);
        return resp.orElse(o.CostValue.of({ amount: 0 }));
    }
    async getUpstreamCostsOf(path) {
        const resp = await this.client._callEach(this.path("upstream-costs-of"), o.UpstreamNode.fromDict, "POST", upstreamPathOf(path));
        return resp.orElse([]);
    }
    //#endregion
    async getSankeyGraph(config) {
        const resp = await this.client._call(this.path("sankey"), o.SankeyGraph.fromDict, "POST", config.toDict());
        return resp.orElseThrow();
    }
}
exports.RestResult = RestResult;
function upstreamPathOf(path) {
    if (!path || path.length === 0) {
        return {};
    }
    let p = "";
    for (const techFlow of path) {
        const providerId = techFlow.provider?.id;
        const flowId = techFlow.flow?.id;
        const next = `${providerId}::${flowId}`;
        p += p.length === 0 ? next : "/" + next;
    }
    return { path: p };
}
function ok(status) {
    return status >= 200 && status < 300;
}
function pathOf(type) {
    switch (type) {
        case o.RefType.Actor:
            return "actors";
        case o.RefType.Currency:
            return "currencies";
        case o.RefType.DQSystem:
            return "dq-systems";
        case o.RefType.Epd:
            return "epds";
        case o.RefType.Flow:
            return "flows";
        case o.RefType.FlowProperty:
            return "flow-properties";
        case o.RefType.ImpactCategory:
            return "impact-categories";
        case o.RefType.ImpactMethod:
            return "impact-methods";
        case o.RefType.Location:
            return "locations";
        case o.RefType.Parameter:
            return "parameters";
        case o.RefType.Process:
            return "processes";
        case o.RefType.ProductSystem:
            return "product-systems";
        case o.RefType.Project:
            return "projects";
        case o.RefType.Result:
            return "results";
        case o.RefType.SocialIndicator:
            return "social-indicators";
        case o.RefType.Source:
            return "sources";
        case o.RefType.UnitGroup:
            return "unit-groups";
    }
    throw Error(`unknown entity type: ${type}`);
}
function techIdOf(t) {
    return `${t?.provider?.id}::${t?.flow?.id}`;
}
function enviIdOf(e) {
    return e?.location ? `${e?.flow?.id}::${e?.location?.id}` : e?.flow?.id || "";
}
