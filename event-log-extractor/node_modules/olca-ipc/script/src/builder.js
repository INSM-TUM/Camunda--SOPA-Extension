"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImpactMethod = exports.createImpactFactor = exports.createImpactCategory = exports.createParameter = exports.createLocation = exports.createCausalAllocationFactor = exports.createEconomicAllocationFactor = exports.createPhysicalAllocationFactor = exports.createOutput = exports.createInput = exports.createProcess = exports.createElementaryFlow = exports.createWaste = exports.createProduct = exports.createFlowProperty = exports.createUnitGroup = exports.createUnit = exports.uuid = void 0;
const o = __importStar(require("./schema.js"));
function uuid() {
    let d = ((typeof performance !== "undefined") && performance.now)
        ? performance.now() * 1000
        : 0;
    if (d === 0) {
        d = new Date().getTime();
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        let r = Math.random() * 16;
        r = (d + r) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : (r & 0x7 | 0x8)).toString(16);
    });
}
exports.uuid = uuid;
//#region units
function createUnit(name, conversionFactor = 1.0) {
    return o.Unit.of({
        name,
        id: uuid(),
        conversionFactor,
        isRefUnit: conversionFactor === 1.0,
    });
}
exports.createUnit = createUnit;
function createUnitGroup(name, refUnit) {
    const unit = typeof refUnit === "string" ? createUnit(refUnit) : refUnit;
    const group = init(new o.UnitGroup(), name);
    group.units = [unit];
    return group;
}
exports.createUnitGroup = createUnitGroup;
function createFlowProperty(name, unitGroup) {
    const prop = init(new o.FlowProperty(), name);
    prop.unitGroup = unitGroup instanceof o.UnitGroup
        ? unitGroup.toRef()
        : unitGroup;
    return prop;
}
exports.createFlowProperty = createFlowProperty;
//#endregion
//#region flows
function createProduct(name, property) {
    return createFlow(name, o.FlowType.PRODUCT_FLOW, property);
}
exports.createProduct = createProduct;
function createWaste(name, property) {
    return createFlow(name, o.FlowType.WASTE_FLOW, property);
}
exports.createWaste = createWaste;
function createElementaryFlow(name, property) {
    return createFlow(name, o.FlowType.ELEMENTARY_FLOW, property);
}
exports.createElementaryFlow = createElementaryFlow;
function createFlow(name, type, property) {
    const flow = init(new o.Flow(), name);
    flow.flowType = type;
    const propRef = property instanceof o.FlowProperty
        ? property.toRef()
        : property;
    flow.flowProperties = [
        o.FlowPropertyFactor.of({
            conversionFactor: 1.0,
            isRefFlowProperty: true,
            flowProperty: propRef,
        }),
    ];
    return flow;
}
//#endregion
//#region processes
function createProcess(name, refFlow) {
    const process = init(new o.Process(), name);
    process.processType = o.ProcessType.UNIT_PROCESS;
    if (refFlow) {
        const qRef = refFlow.flowType === o.FlowType.WASTE_FLOW
            ? createInput(process, refFlow, 1.0)
            : createOutput(process, refFlow, 1.0);
        qRef.isQuantitativeReference = true;
    }
    return process;
}
exports.createProcess = createProcess;
function createInput(process, flow, amount, unit) {
    const e = createExchange(process, flow, amount, unit);
    e.isInput = true;
    return e;
}
exports.createInput = createInput;
function createOutput(process, flow, amount, unit) {
    const e = createExchange(process, flow, amount, unit);
    e.isInput = false;
    return e;
}
exports.createOutput = createOutput;
function createExchange(process, flow, amount, unit) {
    const flowRef = flow instanceof o.Flow ? flow.toRef() : flow;
    const id = process.lastInternalId ? process.lastInternalId + 1 : 1;
    process.lastInternalId = id;
    const e = o.Exchange.of({
        internalId: id,
        flow: flowRef,
    });
    if (isFloat(amount)) {
        e.amount = amount;
    }
    else {
        e.amountFormula = amount;
    }
    if (unit) {
        e.unit = unit instanceof o.Unit ? unit.toRef() : unit;
    }
    if (process.exchanges) {
        process.exchanges.push(e);
    }
    else {
        process.exchanges = [e];
    }
    return e;
}
function createPhysicalAllocationFactor(process, product, value) {
    const f = createAllocationFactor(process, product, value);
    f.allocationType = o.AllocationType.PHYSICAL_ALLOCATION;
    return f;
}
exports.createPhysicalAllocationFactor = createPhysicalAllocationFactor;
function createEconomicAllocationFactor(process, product, value) {
    const f = createAllocationFactor(process, product, value);
    f.allocationType = o.AllocationType.ECONOMIC_ALLOCATION;
    return f;
}
exports.createEconomicAllocationFactor = createEconomicAllocationFactor;
function createCausalAllocationFactor(process, product, value, exchange) {
    const f = createAllocationFactor(process, product, value);
    f.allocationType = o.AllocationType.CAUSAL_ALLOCATION;
    f.exchange = exchange instanceof o.Exchange
        ? o.ExchangeRef.of({ internalId: exchange.internalId })
        : exchange;
    return f;
}
exports.createCausalAllocationFactor = createCausalAllocationFactor;
function createAllocationFactor(process, product, value) {
    const factor = new o.AllocationFactor();
    factor.product = product instanceof o.Flow ? product.toRef() : product;
    if (isFloat(value)) {
        factor.value = value;
    }
    else {
        factor.formula = value;
    }
    if (process.allocationFactors) {
        process.allocationFactors.push(factor);
    }
    else {
        process.allocationFactors = [factor];
    }
    return factor;
}
//#endregion
function createLocation(name, code) {
    const loc = init(new o.Location(), name);
    loc.code = code || name;
    return loc;
}
exports.createLocation = createLocation;
function createParameter(name, value, scope = o.ParameterScope.GLOBAL_SCOPE) {
    const param = init(new o.Parameter(), name);
    param.parameterScope = scope;
    if (isFloat(value)) {
        param.isInputParameter = true;
        param.value = value;
    }
    else {
        param.isInputParameter = false;
        param.formula = value;
    }
    return param;
}
exports.createParameter = createParameter;
function createImpactCategory(name, refUnit) {
    const i = init(new o.ImpactCategory(), name);
    i.refUnit = refUnit;
    return i;
}
exports.createImpactCategory = createImpactCategory;
function createImpactFactor(indicator, flow, value, unit) {
    const f = new o.ImpactFactor();
    f.flow = flow instanceof o.Flow ? flow.toRef() : flow;
    if (isFloat(value)) {
        f.value = value;
    }
    else {
        f.formula = value;
    }
    if (unit) {
        f.unit = unit instanceof o.Unit ? unit.toRef() : unit;
    }
    if (indicator.impactFactors) {
        indicator.impactFactors.push(f);
    }
    else {
        indicator.impactFactors = [f];
    }
    return f;
}
exports.createImpactFactor = createImpactFactor;
function createImpactMethod(name, indicators) {
    const method = init(new o.ImpactMethod(), name);
    if (indicators) {
        method.impactCategories = indicators.map((i) => i instanceof o.ImpactCategory ? i.toRef() : i);
    }
    return method;
}
exports.createImpactMethod = createImpactMethod;
function init(entity, name) {
    entity.id = uuid();
    entity.name = name;
    entity.lastChange = new Date().toISOString();
    entity.version = "01.00.000";
    return entity;
}
function isFloat(n) {
    return typeof n === "number";
}
