"use strict";
// this file was generated automatically; do not change it but help to make
// the code generator better; see:
// https://github.com/GreenDelta/olca-schema/tree/master/osch
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ref = exports.ProjectVariant = exports.Project = exports.ProductSystem = exports.ProcessLink = exports.ProcessDocumentation = exports.Process = exports.ParameterRedefSet = exports.ParameterRedef = exports.Parameter = exports.NwSet = exports.NwFactor = exports.Location = exports.LinkingConfig = exports.ImpactResult = exports.ImpactMethod = exports.ImpactFactor = exports.ImpactCategory = exports.FlowResult = exports.FlowPropertyFactor = exports.FlowProperty = exports.FlowMapRef = exports.FlowMapEntry = exports.FlowMap = exports.Flow = exports.ExchangeRef = exports.Exchange = exports.EpdProduct = exports.EpdModule = exports.Epd = exports.DQSystem = exports.DQScore = exports.DQIndicator = exports.Currency = exports.ComplianceDeclaration = exports.AspectValue = exports.AllocationFactor = exports.Actor = exports.UncertaintyType = exports.RiskLevel = exports.ProviderLinking = exports.ProcessType = exports.ParameterScope = exports.ModelType = exports.FlowType = exports.FlowPropertyType = exports.EpdType = exports.Direction = exports.AllocationType = exports.RefType = void 0;
exports.UpstreamNode = exports.TechFlowValue = exports.TechFlow = exports.SankeyRequest = exports.SankeyNode = exports.SankeyGraph = exports.SankeyEdge = exports.ResultState = exports.ImpactValue = exports.EnviFlowValue = exports.EnviFlow = exports.CostValue = exports.CalculationSetup = exports.UnitGroup = exports.Unit = exports.Uncertainty = exports.Source = exports.SocialIndicator = exports.SocialAspect = exports.ReviewScope = exports.Review = exports.Result = void 0;
function ifPresent(val, consumer) {
    if (val !== null && val !== undefined) {
        consumer(val);
    }
}
function dictAll(list) {
    return list ? list.map((e) => e.toDict()) : [];
}
// #endregion
var RefType;
(function (RefType) {
    RefType["Actor"] = "Actor";
    RefType["Currency"] = "Currency";
    RefType["DQSystem"] = "DQSystem";
    RefType["Epd"] = "Epd";
    RefType["Flow"] = "Flow";
    RefType["FlowMap"] = "FlowMap";
    RefType["FlowProperty"] = "FlowProperty";
    RefType["ImpactCategory"] = "ImpactCategory";
    RefType["ImpactMethod"] = "ImpactMethod";
    RefType["Location"] = "Location";
    RefType["NwSet"] = "NwSet";
    RefType["Parameter"] = "Parameter";
    RefType["Process"] = "Process";
    RefType["ProductSystem"] = "ProductSystem";
    RefType["Project"] = "Project";
    RefType["Result"] = "Result";
    RefType["SocialIndicator"] = "SocialIndicator";
    RefType["Source"] = "Source";
    RefType["Unit"] = "Unit";
    RefType["UnitGroup"] = "UnitGroup";
})(RefType = exports.RefType || (exports.RefType = {}));
var AllocationType;
(function (AllocationType) {
    AllocationType["PHYSICAL_ALLOCATION"] = "PHYSICAL_ALLOCATION";
    AllocationType["ECONOMIC_ALLOCATION"] = "ECONOMIC_ALLOCATION";
    AllocationType["CAUSAL_ALLOCATION"] = "CAUSAL_ALLOCATION";
    AllocationType["USE_DEFAULT_ALLOCATION"] = "USE_DEFAULT_ALLOCATION";
    AllocationType["NO_ALLOCATION"] = "NO_ALLOCATION";
})(AllocationType = exports.AllocationType || (exports.AllocationType = {}));
var Direction;
(function (Direction) {
    Direction["INPUT"] = "INPUT";
    Direction["OUTPUT"] = "OUTPUT";
})(Direction = exports.Direction || (exports.Direction = {}));
var EpdType;
(function (EpdType) {
    EpdType["GENERIC_DATASET"] = "GENERIC_DATASET";
    EpdType["REPRESENTATIVE_DATASET"] = "REPRESENTATIVE_DATASET";
    EpdType["AVERAGE_DATASET"] = "AVERAGE_DATASET";
    EpdType["SPECIFIC_DATASET"] = "SPECIFIC_DATASET";
    EpdType["TEMPLATE_DATASET"] = "TEMPLATE_DATASET";
})(EpdType = exports.EpdType || (exports.EpdType = {}));
var FlowPropertyType;
(function (FlowPropertyType) {
    FlowPropertyType["ECONOMIC_QUANTITY"] = "ECONOMIC_QUANTITY";
    FlowPropertyType["PHYSICAL_QUANTITY"] = "PHYSICAL_QUANTITY";
})(FlowPropertyType = exports.FlowPropertyType || (exports.FlowPropertyType = {}));
var FlowType;
(function (FlowType) {
    FlowType["ELEMENTARY_FLOW"] = "ELEMENTARY_FLOW";
    FlowType["PRODUCT_FLOW"] = "PRODUCT_FLOW";
    FlowType["WASTE_FLOW"] = "WASTE_FLOW";
})(FlowType = exports.FlowType || (exports.FlowType = {}));
var ModelType;
(function (ModelType) {
    ModelType["ACTOR"] = "ACTOR";
    ModelType["CATEGORY"] = "CATEGORY";
    ModelType["CURRENCY"] = "CURRENCY";
    ModelType["DQ_SYSTEM"] = "DQ_SYSTEM";
    ModelType["EPD"] = "EPD";
    ModelType["FLOW"] = "FLOW";
    ModelType["FLOW_PROPERTY"] = "FLOW_PROPERTY";
    ModelType["IMPACT_CATEGORY"] = "IMPACT_CATEGORY";
    ModelType["IMPACT_METHOD"] = "IMPACT_METHOD";
    ModelType["LOCATION"] = "LOCATION";
    ModelType["PARAMETER"] = "PARAMETER";
    ModelType["PROCESS"] = "PROCESS";
    ModelType["PRODUCT_SYSTEM"] = "PRODUCT_SYSTEM";
    ModelType["PROJECT"] = "PROJECT";
    ModelType["RESULT"] = "RESULT";
    ModelType["SOCIAL_INDICATOR"] = "SOCIAL_INDICATOR";
    ModelType["SOURCE"] = "SOURCE";
    ModelType["UNIT_GROUP"] = "UNIT_GROUP";
})(ModelType = exports.ModelType || (exports.ModelType = {}));
var ParameterScope;
(function (ParameterScope) {
    ParameterScope["PROCESS_SCOPE"] = "PROCESS_SCOPE";
    ParameterScope["IMPACT_SCOPE"] = "IMPACT_SCOPE";
    ParameterScope["GLOBAL_SCOPE"] = "GLOBAL_SCOPE";
})(ParameterScope = exports.ParameterScope || (exports.ParameterScope = {}));
var ProcessType;
(function (ProcessType) {
    ProcessType["LCI_RESULT"] = "LCI_RESULT";
    ProcessType["UNIT_PROCESS"] = "UNIT_PROCESS";
})(ProcessType = exports.ProcessType || (exports.ProcessType = {}));
var ProviderLinking;
(function (ProviderLinking) {
    ProviderLinking["IGNORE_DEFAULTS"] = "IGNORE_DEFAULTS";
    ProviderLinking["PREFER_DEFAULTS"] = "PREFER_DEFAULTS";
    ProviderLinking["ONLY_DEFAULTS"] = "ONLY_DEFAULTS";
})(ProviderLinking = exports.ProviderLinking || (exports.ProviderLinking = {}));
var RiskLevel;
(function (RiskLevel) {
    RiskLevel["NO_OPPORTUNITY"] = "NO_OPPORTUNITY";
    RiskLevel["HIGH_OPPORTUNITY"] = "HIGH_OPPORTUNITY";
    RiskLevel["MEDIUM_OPPORTUNITY"] = "MEDIUM_OPPORTUNITY";
    RiskLevel["LOW_OPPORTUNITY"] = "LOW_OPPORTUNITY";
    RiskLevel["NO_RISK"] = "NO_RISK";
    RiskLevel["VERY_LOW_RISK"] = "VERY_LOW_RISK";
    RiskLevel["LOW_RISK"] = "LOW_RISK";
    RiskLevel["MEDIUM_RISK"] = "MEDIUM_RISK";
    RiskLevel["HIGH_RISK"] = "HIGH_RISK";
    RiskLevel["VERY_HIGH_RISK"] = "VERY_HIGH_RISK";
    RiskLevel["NO_DATA"] = "NO_DATA";
    RiskLevel["NOT_APPLICABLE"] = "NOT_APPLICABLE";
})(RiskLevel = exports.RiskLevel || (exports.RiskLevel = {}));
var UncertaintyType;
(function (UncertaintyType) {
    UncertaintyType["LOG_NORMAL_DISTRIBUTION"] = "LOG_NORMAL_DISTRIBUTION";
    UncertaintyType["NORMAL_DISTRIBUTION"] = "NORMAL_DISTRIBUTION";
    UncertaintyType["TRIANGLE_DISTRIBUTION"] = "TRIANGLE_DISTRIBUTION";
    UncertaintyType["UNIFORM_DISTRIBUTION"] = "UNIFORM_DISTRIBUTION";
})(UncertaintyType = exports.UncertaintyType || (exports.UncertaintyType = {}));
class Actor {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "address", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "city", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "country", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "email", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "telefax", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "telephone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "website", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "zipCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Actor();
        e.id = i.id;
        e.address = i.address;
        e.category = i.category;
        e.city = i.city;
        e.country = i.country;
        e.description = i.description;
        e.email = i.email;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.tags = i.tags;
        e.telefax = i.telefax;
        e.telephone = i.telephone;
        e.version = i.version;
        e.website = i.website;
        e.zipCode = i.zipCode;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Actor,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Actor";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.address, (v) => d.address = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.city, (v) => d.city = v);
        ifPresent(this.country, (v) => d.country = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.email, (v) => d.email = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.telefax, (v) => d.telefax = v);
        ifPresent(this.telephone, (v) => d.telephone = v);
        ifPresent(this.version, (v) => d.version = v);
        ifPresent(this.website, (v) => d.website = v);
        ifPresent(this.zipCode, (v) => d.zipCode = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Actor();
        e.id = d["@id"];
        e.address = d.address;
        e.category = d.category;
        e.city = d.city;
        e.country = d.country;
        e.description = d.description;
        e.email = d.email;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.tags = d.tags;
        e.telefax = d.telefax;
        e.telephone = d.telephone;
        e.version = d.version;
        e.website = d.website;
        e.zipCode = d.zipCode;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Actor.fromDict(JSON.parse(json))
            : Actor.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Actor = Actor;
class AllocationFactor {
    constructor() {
        Object.defineProperty(this, "allocationType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exchange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "product", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new AllocationFactor();
        e.allocationType = i.allocationType;
        e.exchange = i.exchange;
        e.formula = i.formula;
        e.product = i.product;
        e.value = i.value;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.allocationType, (v) => d.allocationType = v);
        ifPresent(this.exchange, (v) => d.exchange = v?.toDict());
        ifPresent(this.formula, (v) => d.formula = v);
        ifPresent(this.product, (v) => d.product = v?.toDict());
        ifPresent(this.value, (v) => d.value = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new AllocationFactor();
        e.allocationType = d.allocationType;
        e.exchange = ExchangeRef.fromDict(d.exchange);
        e.formula = d.formula;
        e.product = Ref.fromDict(d.product);
        e.value = d.value;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? AllocationFactor.fromDict(JSON.parse(json))
            : AllocationFactor.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.AllocationFactor = AllocationFactor;
class AspectValue {
    constructor() {
        Object.defineProperty(this, "aspect", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new AspectValue();
        e.aspect = i.aspect;
        e.value = i.value;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.aspect, (v) => d.aspect = v);
        ifPresent(this.value, (v) => d.value = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new AspectValue();
        e.aspect = d.aspect;
        e.value = d.value;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? AspectValue.fromDict(JSON.parse(json))
            : AspectValue.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.AspectValue = AspectValue;
class ComplianceDeclaration {
    constructor() {
        Object.defineProperty(this, "aspects", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "comment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "system", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ComplianceDeclaration();
        e.aspects = i.aspects;
        e.comment = i.comment;
        e.system = i.system;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.aspects, (v) => d.aspects = dictAll(v));
        ifPresent(this.comment, (v) => d.comment = v);
        ifPresent(this.system, (v) => d.system = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ComplianceDeclaration();
        e.aspects = d.aspects
            ? d.aspects.map(AspectValue.fromDict)
            : null;
        e.comment = d.comment;
        e.system = Ref.fromDict(d.system);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ComplianceDeclaration.fromDict(JSON.parse(json))
            : ComplianceDeclaration.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ComplianceDeclaration = ComplianceDeclaration;
class Currency {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversionFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refCurrency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Currency();
        e.id = i.id;
        e.category = i.category;
        e.code = i.code;
        e.conversionFactor = i.conversionFactor;
        e.description = i.description;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.refCurrency = i.refCurrency;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Currency,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Currency";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.code, (v) => d.code = v);
        ifPresent(this.conversionFactor, (v) => d.conversionFactor = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.refCurrency, (v) => d.refCurrency = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Currency();
        e.id = d["@id"];
        e.category = d.category;
        e.code = d.code;
        e.conversionFactor = d.conversionFactor;
        e.description = d.description;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.refCurrency = Ref.fromDict(d.refCurrency);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Currency.fromDict(JSON.parse(json))
            : Currency.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Currency = Currency;
class DQIndicator {
    constructor() {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "position", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scores", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new DQIndicator();
        e.name = i.name;
        e.position = i.position;
        e.scores = i.scores;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.position, (v) => d.position = v);
        ifPresent(this.scores, (v) => d.scores = dictAll(v));
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new DQIndicator();
        e.name = d.name;
        e.position = d.position;
        e.scores = d.scores
            ? d.scores.map(DQScore.fromDict)
            : null;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? DQIndicator.fromDict(JSON.parse(json))
            : DQIndicator.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.DQIndicator = DQIndicator;
class DQScore {
    constructor() {
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "label", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "position", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new DQScore();
        e.description = i.description;
        e.label = i.label;
        e.position = i.position;
        e.uncertainty = i.uncertainty;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.label, (v) => d.label = v);
        ifPresent(this.position, (v) => d.position = v);
        ifPresent(this.uncertainty, (v) => d.uncertainty = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new DQScore();
        e.description = d.description;
        e.label = d.label;
        e.position = d.position;
        e.uncertainty = d.uncertainty;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? DQScore.fromDict(JSON.parse(json))
            : DQScore.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.DQScore = DQScore;
class DQSystem {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hasUncertainties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "indicators", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new DQSystem();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.hasUncertainties = i.hasUncertainties;
        e.indicators = i.indicators;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.source = i.source;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.DQSystem,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "DQSystem";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.hasUncertainties, (v) => d.hasUncertainties = v);
        ifPresent(this.indicators, (v) => d.indicators = dictAll(v));
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.source, (v) => d.source = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new DQSystem();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.hasUncertainties = d.hasUncertainties;
        e.indicators = d.indicators
            ? d.indicators.map(DQIndicator.fromDict)
            : null;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.source = Ref.fromDict(d.source);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? DQSystem.fromDict(JSON.parse(json))
            : DQSystem.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.DQSystem = DQSystem;
class Epd {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "epdType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "manufacturer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "manufacturing", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "originalEpd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pcr", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "product", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "productUsage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "programOperator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "registrationId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "urn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "useAdvice", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validFrom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validUntil", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "verifier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Epd();
        e.id = i.id;
        e.category = i.category;
        e.dataGenerator = i.dataGenerator;
        e.description = i.description;
        e.epdType = i.epdType;
        e.lastChange = i.lastChange;
        e.location = i.location;
        e.manufacturer = i.manufacturer;
        e.manufacturing = i.manufacturing;
        e.modules = i.modules;
        e.name = i.name;
        e.originalEpd = i.originalEpd;
        e.pcr = i.pcr;
        e.product = i.product;
        e.productUsage = i.productUsage;
        e.programOperator = i.programOperator;
        e.registrationId = i.registrationId;
        e.tags = i.tags;
        e.urn = i.urn;
        e.useAdvice = i.useAdvice;
        e.validFrom = i.validFrom;
        e.validUntil = i.validUntil;
        e.verifier = i.verifier;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Epd,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Epd";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.dataGenerator, (v) => d.dataGenerator = v?.toDict());
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.epdType, (v) => d.epdType = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.manufacturer, (v) => d.manufacturer = v?.toDict());
        ifPresent(this.manufacturing, (v) => d.manufacturing = v);
        ifPresent(this.modules, (v) => d.modules = dictAll(v));
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.originalEpd, (v) => d.originalEpd = v?.toDict());
        ifPresent(this.pcr, (v) => d.pcr = v?.toDict());
        ifPresent(this.product, (v) => d.product = v?.toDict());
        ifPresent(this.productUsage, (v) => d.productUsage = v);
        ifPresent(this.programOperator, (v) => d.programOperator = v?.toDict());
        ifPresent(this.registrationId, (v) => d.registrationId = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.urn, (v) => d.urn = v);
        ifPresent(this.useAdvice, (v) => d.useAdvice = v);
        ifPresent(this.validFrom, (v) => d.validFrom = v);
        ifPresent(this.validUntil, (v) => d.validUntil = v);
        ifPresent(this.verifier, (v) => d.verifier = v?.toDict());
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Epd();
        e.id = d["@id"];
        e.category = d.category;
        e.dataGenerator = Ref.fromDict(d.dataGenerator);
        e.description = d.description;
        e.epdType = d.epdType;
        e.lastChange = d.lastChange;
        e.location = Ref.fromDict(d.location);
        e.manufacturer = Ref.fromDict(d.manufacturer);
        e.manufacturing = d.manufacturing;
        e.modules = d.modules
            ? d.modules.map(EpdModule.fromDict)
            : null;
        e.name = d.name;
        e.originalEpd = Ref.fromDict(d.originalEpd);
        e.pcr = Ref.fromDict(d.pcr);
        e.product = EpdProduct.fromDict(d.product);
        e.productUsage = d.productUsage;
        e.programOperator = Ref.fromDict(d.programOperator);
        e.registrationId = d.registrationId;
        e.tags = d.tags;
        e.urn = d.urn;
        e.useAdvice = d.useAdvice;
        e.validFrom = d.validFrom;
        e.validUntil = d.validUntil;
        e.verifier = Ref.fromDict(d.verifier);
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Epd.fromDict(JSON.parse(json))
            : Epd.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Epd = Epd;
class EpdModule {
    constructor() {
        Object.defineProperty(this, "multiplier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new EpdModule();
        e.multiplier = i.multiplier;
        e.name = i.name;
        e.result = i.result;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.multiplier, (v) => d.multiplier = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.result, (v) => d.result = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new EpdModule();
        e.multiplier = d.multiplier;
        e.name = d.name;
        e.result = Ref.fromDict(d.result);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? EpdModule.fromDict(JSON.parse(json))
            : EpdModule.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.EpdModule = EpdModule;
class EpdProduct {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new EpdProduct();
        e.amount = i.amount;
        e.flow = i.flow;
        e.flowProperty = i.flowProperty;
        e.unit = i.unit;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new EpdProduct();
        e.amount = d.amount;
        e.flow = Ref.fromDict(d.flow);
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.unit = Ref.fromDict(d.unit);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? EpdProduct.fromDict(JSON.parse(json))
            : EpdProduct.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.EpdProduct = EpdProduct;
class Exchange {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "amountFormula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseUncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "costFormula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "costValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "currency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultProvider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dqEntry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "internalId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isAvoidedProduct", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isQuantitativeReference", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Exchange();
        e.amount = i.amount;
        e.amountFormula = i.amountFormula;
        e.baseUncertainty = i.baseUncertainty;
        e.costFormula = i.costFormula;
        e.costValue = i.costValue;
        e.currency = i.currency;
        e.defaultProvider = i.defaultProvider;
        e.description = i.description;
        e.dqEntry = i.dqEntry;
        e.flow = i.flow;
        e.flowProperty = i.flowProperty;
        e.internalId = i.internalId;
        e.isAvoidedProduct = i.isAvoidedProduct;
        e.isInput = i.isInput;
        e.isQuantitativeReference = i.isQuantitativeReference;
        e.location = i.location;
        e.uncertainty = i.uncertainty;
        e.unit = i.unit;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.amountFormula, (v) => d.amountFormula = v);
        ifPresent(this.baseUncertainty, (v) => d.baseUncertainty = v);
        ifPresent(this.costFormula, (v) => d.costFormula = v);
        ifPresent(this.costValue, (v) => d.costValue = v);
        ifPresent(this.currency, (v) => d.currency = v?.toDict());
        ifPresent(this.defaultProvider, (v) => d.defaultProvider = v?.toDict());
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.dqEntry, (v) => d.dqEntry = v);
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.internalId, (v) => d.internalId = v);
        ifPresent(this.isAvoidedProduct, (v) => d.isAvoidedProduct = v);
        ifPresent(this.isInput, (v) => d.isInput = v);
        ifPresent(this.isQuantitativeReference, (v) => d.isQuantitativeReference = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.uncertainty, (v) => d.uncertainty = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Exchange();
        e.amount = d.amount;
        e.amountFormula = d.amountFormula;
        e.baseUncertainty = d.baseUncertainty;
        e.costFormula = d.costFormula;
        e.costValue = d.costValue;
        e.currency = Ref.fromDict(d.currency);
        e.defaultProvider = Ref.fromDict(d.defaultProvider);
        e.description = d.description;
        e.dqEntry = d.dqEntry;
        e.flow = Ref.fromDict(d.flow);
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.internalId = d.internalId;
        e.isAvoidedProduct = d.isAvoidedProduct;
        e.isInput = d.isInput;
        e.isQuantitativeReference = d.isQuantitativeReference;
        e.location = Ref.fromDict(d.location);
        e.uncertainty = Uncertainty.fromDict(d.uncertainty);
        e.unit = Ref.fromDict(d.unit);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Exchange.fromDict(JSON.parse(json))
            : Exchange.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Exchange = Exchange;
class ExchangeRef {
    constructor() {
        Object.defineProperty(this, "internalId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ExchangeRef();
        e.internalId = i.internalId;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.internalId, (v) => d.internalId = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ExchangeRef();
        e.internalId = d.internalId;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ExchangeRef.fromDict(JSON.parse(json))
            : ExchangeRef.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ExchangeRef = ExchangeRef;
class Flow {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperties", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInfrastructureFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "synonyms", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Flow();
        e.id = i.id;
        e.cas = i.cas;
        e.category = i.category;
        e.description = i.description;
        e.flowProperties = i.flowProperties;
        e.flowType = i.flowType;
        e.formula = i.formula;
        e.isInfrastructureFlow = i.isInfrastructureFlow;
        e.lastChange = i.lastChange;
        e.location = i.location;
        e.name = i.name;
        e.synonyms = i.synonyms;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Flow,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Flow";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.cas, (v) => d.cas = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.flowProperties, (v) => d.flowProperties = dictAll(v));
        ifPresent(this.flowType, (v) => d.flowType = v);
        ifPresent(this.formula, (v) => d.formula = v);
        ifPresent(this.isInfrastructureFlow, (v) => d.isInfrastructureFlow = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.synonyms, (v) => d.synonyms = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Flow();
        e.id = d["@id"];
        e.cas = d.cas;
        e.category = d.category;
        e.description = d.description;
        e.flowProperties = d.flowProperties
            ? d.flowProperties.map(FlowPropertyFactor.fromDict)
            : null;
        e.flowType = d.flowType;
        e.formula = d.formula;
        e.isInfrastructureFlow = d.isInfrastructureFlow;
        e.lastChange = d.lastChange;
        e.location = Ref.fromDict(d.location);
        e.name = d.name;
        e.synonyms = d.synonyms;
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Flow.fromDict(JSON.parse(json))
            : Flow.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Flow = Flow;
class FlowMap {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mappings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowMap();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.lastChange = i.lastChange;
        e.mappings = i.mappings;
        e.name = i.name;
        e.source = i.source;
        e.tags = i.tags;
        e.target = i.target;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.FlowMap,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "FlowMap";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.mappings, (v) => d.mappings = dictAll(v));
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.source, (v) => d.source = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.target, (v) => d.target = v?.toDict());
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowMap();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.lastChange = d.lastChange;
        e.mappings = d.mappings
            ? d.mappings.map(FlowMapEntry.fromDict)
            : null;
        e.name = d.name;
        e.source = Ref.fromDict(d.source);
        e.tags = d.tags;
        e.target = Ref.fromDict(d.target);
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowMap.fromDict(JSON.parse(json))
            : FlowMap.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowMap = FlowMap;
class FlowMapEntry {
    constructor() {
        Object.defineProperty(this, "conversionFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "from", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "to", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowMapEntry();
        e.conversionFactor = i.conversionFactor;
        e.from = i.from;
        e.to = i.to;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.conversionFactor, (v) => d.conversionFactor = v);
        ifPresent(this.from, (v) => d.from = v?.toDict());
        ifPresent(this.to, (v) => d.to = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowMapEntry();
        e.conversionFactor = d.conversionFactor;
        e.from = FlowMapRef.fromDict(d.from);
        e.to = FlowMapRef.fromDict(d.to);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowMapEntry.fromDict(JSON.parse(json))
            : FlowMapEntry.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowMapEntry = FlowMapEntry;
class FlowMapRef {
    constructor() {
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowMapRef();
        e.flow = i.flow;
        e.flowProperty = i.flowProperty;
        e.provider = i.provider;
        e.unit = i.unit;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.provider, (v) => d.provider = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowMapRef();
        e.flow = Ref.fromDict(d.flow);
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.provider = Ref.fromDict(d.provider);
        e.unit = Ref.fromDict(d.unit);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowMapRef.fromDict(JSON.parse(json))
            : FlowMapRef.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowMapRef = FlowMapRef;
class FlowProperty {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowPropertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unitGroup", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowProperty();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.flowPropertyType = i.flowPropertyType;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.tags = i.tags;
        e.unitGroup = i.unitGroup;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.FlowProperty,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "FlowProperty";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.flowPropertyType, (v) => d.flowPropertyType = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.unitGroup, (v) => d.unitGroup = v?.toDict());
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowProperty();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.flowPropertyType = d.flowPropertyType;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.tags = d.tags;
        e.unitGroup = Ref.fromDict(d.unitGroup);
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowProperty.fromDict(JSON.parse(json))
            : FlowProperty.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowProperty = FlowProperty;
class FlowPropertyFactor {
    constructor() {
        Object.defineProperty(this, "conversionFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isRefFlowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowPropertyFactor();
        e.conversionFactor = i.conversionFactor;
        e.flowProperty = i.flowProperty;
        e.isRefFlowProperty = i.isRefFlowProperty;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.conversionFactor, (v) => d.conversionFactor = v);
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.isRefFlowProperty, (v) => d.isRefFlowProperty = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowPropertyFactor();
        e.conversionFactor = d.conversionFactor;
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.isRefFlowProperty = d.isRefFlowProperty;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowPropertyFactor.fromDict(JSON.parse(json))
            : FlowPropertyFactor.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowPropertyFactor = FlowPropertyFactor;
class FlowResult {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isRefFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new FlowResult();
        e.amount = i.amount;
        e.description = i.description;
        e.flow = i.flow;
        e.flowProperty = i.flowProperty;
        e.isInput = i.isInput;
        e.isRefFlow = i.isRefFlow;
        e.location = i.location;
        e.unit = i.unit;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.isInput, (v) => d.isInput = v);
        ifPresent(this.isRefFlow, (v) => d.isRefFlow = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new FlowResult();
        e.amount = d.amount;
        e.description = d.description;
        e.flow = Ref.fromDict(d.flow);
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.isInput = d.isInput;
        e.isRefFlow = d.isRefFlow;
        e.location = Ref.fromDict(d.location);
        e.unit = Ref.fromDict(d.unit);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? FlowResult.fromDict(JSON.parse(json))
            : FlowResult.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.FlowResult = FlowResult;
class ImpactCategory {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "direction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactFactors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ImpactCategory();
        e.id = i.id;
        e.category = i.category;
        e.code = i.code;
        e.description = i.description;
        e.direction = i.direction;
        e.impactFactors = i.impactFactors;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.parameters = i.parameters;
        e.refUnit = i.refUnit;
        e.source = i.source;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.ImpactCategory,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "ImpactCategory";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.code, (v) => d.code = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.direction, (v) => d.direction = v);
        ifPresent(this.impactFactors, (v) => d.impactFactors = dictAll(v));
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameters, (v) => d.parameters = dictAll(v));
        ifPresent(this.refUnit, (v) => d.refUnit = v);
        ifPresent(this.source, (v) => d.source = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ImpactCategory();
        e.id = d["@id"];
        e.category = d.category;
        e.code = d.code;
        e.description = d.description;
        e.direction = d.direction;
        e.impactFactors = d.impactFactors
            ? d.impactFactors.map(ImpactFactor.fromDict)
            : null;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.parameters = d.parameters
            ? d.parameters.map(Parameter.fromDict)
            : null;
        e.refUnit = d.refUnit;
        e.source = Ref.fromDict(d.source);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ImpactCategory.fromDict(JSON.parse(json))
            : ImpactCategory.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ImpactCategory = ImpactCategory;
class ImpactFactor {
    constructor() {
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ImpactFactor();
        e.flow = i.flow;
        e.flowProperty = i.flowProperty;
        e.formula = i.formula;
        e.location = i.location;
        e.uncertainty = i.uncertainty;
        e.unit = i.unit;
        e.value = i.value;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.formula, (v) => d.formula = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.uncertainty, (v) => d.uncertainty = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        ifPresent(this.value, (v) => d.value = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ImpactFactor();
        e.flow = Ref.fromDict(d.flow);
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.formula = d.formula;
        e.location = Ref.fromDict(d.location);
        e.uncertainty = Uncertainty.fromDict(d.uncertainty);
        e.unit = Ref.fromDict(d.unit);
        e.value = d.value;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ImpactFactor.fromDict(JSON.parse(json))
            : ImpactFactor.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ImpactFactor = ImpactFactor;
class ImpactMethod {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactCategories", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nwSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ImpactMethod();
        e.id = i.id;
        e.category = i.category;
        e.code = i.code;
        e.description = i.description;
        e.impactCategories = i.impactCategories;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.nwSets = i.nwSets;
        e.source = i.source;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.ImpactMethod,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "ImpactMethod";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.code, (v) => d.code = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.impactCategories, (v) => d.impactCategories = dictAll(v));
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.nwSets, (v) => d.nwSets = dictAll(v));
        ifPresent(this.source, (v) => d.source = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ImpactMethod();
        e.id = d["@id"];
        e.category = d.category;
        e.code = d.code;
        e.description = d.description;
        e.impactCategories = d.impactCategories
            ? d.impactCategories.map(Ref.fromDict)
            : null;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.nwSets = d.nwSets
            ? d.nwSets.map(NwSet.fromDict)
            : null;
        e.source = Ref.fromDict(d.source);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ImpactMethod.fromDict(JSON.parse(json))
            : ImpactMethod.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ImpactMethod = ImpactMethod;
class ImpactResult {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "indicator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ImpactResult();
        e.amount = i.amount;
        e.description = i.description;
        e.indicator = i.indicator;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.indicator, (v) => d.indicator = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ImpactResult();
        e.amount = d.amount;
        e.description = d.description;
        e.indicator = Ref.fromDict(d.indicator);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ImpactResult.fromDict(JSON.parse(json))
            : ImpactResult.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ImpactResult = ImpactResult;
class LinkingConfig {
    constructor() {
        Object.defineProperty(this, "cutoff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "preferUnitProcesses", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "providerLinking", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new LinkingConfig();
        e.cutoff = i.cutoff;
        e.preferUnitProcesses = i.preferUnitProcesses;
        e.providerLinking = i.providerLinking;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.cutoff, (v) => d.cutoff = v);
        ifPresent(this.preferUnitProcesses, (v) => d.preferUnitProcesses = v);
        ifPresent(this.providerLinking, (v) => d.providerLinking = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new LinkingConfig();
        e.cutoff = d.cutoff;
        e.preferUnitProcesses = d.preferUnitProcesses;
        e.providerLinking = d.providerLinking;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? LinkingConfig.fromDict(JSON.parse(json))
            : LinkingConfig.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.LinkingConfig = LinkingConfig;
class Location {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "geometry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "latitude", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "longitude", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Location();
        e.id = i.id;
        e.category = i.category;
        e.code = i.code;
        e.description = i.description;
        e.geometry = i.geometry;
        e.lastChange = i.lastChange;
        e.latitude = i.latitude;
        e.longitude = i.longitude;
        e.name = i.name;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Location,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Location";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.code, (v) => d.code = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.geometry, (v) => d.geometry = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.latitude, (v) => d.latitude = v);
        ifPresent(this.longitude, (v) => d.longitude = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Location();
        e.id = d["@id"];
        e.category = d.category;
        e.code = d.code;
        e.description = d.description;
        e.geometry = d.geometry;
        e.lastChange = d.lastChange;
        e.latitude = d.latitude;
        e.longitude = d.longitude;
        e.name = d.name;
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Location.fromDict(JSON.parse(json))
            : Location.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Location = Location;
class NwFactor {
    constructor() {
        Object.defineProperty(this, "impactCategory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "normalisationFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "weightingFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new NwFactor();
        e.impactCategory = i.impactCategory;
        e.normalisationFactor = i.normalisationFactor;
        e.weightingFactor = i.weightingFactor;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.impactCategory, (v) => d.impactCategory = v?.toDict());
        ifPresent(this.normalisationFactor, (v) => d.normalisationFactor = v);
        ifPresent(this.weightingFactor, (v) => d.weightingFactor = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new NwFactor();
        e.impactCategory = Ref.fromDict(d.impactCategory);
        e.normalisationFactor = d.normalisationFactor;
        e.weightingFactor = d.weightingFactor;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? NwFactor.fromDict(JSON.parse(json))
            : NwFactor.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.NwFactor = NwFactor;
class NwSet {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "factors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "weightedScoreUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new NwSet();
        e.id = i.id;
        e.description = i.description;
        e.factors = i.factors;
        e.name = i.name;
        e.weightedScoreUnit = i.weightedScoreUnit;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.NwSet,
            id: this.id,
            name: this.name,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "NwSet";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.factors, (v) => d.factors = dictAll(v));
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.weightedScoreUnit, (v) => d.weightedScoreUnit = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new NwSet();
        e.id = d["@id"];
        e.description = d.description;
        e.factors = d.factors
            ? d.factors.map(NwFactor.fromDict)
            : null;
        e.name = d.name;
        e.weightedScoreUnit = d.weightedScoreUnit;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? NwSet.fromDict(JSON.parse(json))
            : NwSet.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.NwSet = NwSet;
class Parameter {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formula", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInputParameter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameterScope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Parameter();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.formula = i.formula;
        e.isInputParameter = i.isInputParameter;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.parameterScope = i.parameterScope;
        e.tags = i.tags;
        e.uncertainty = i.uncertainty;
        e.value = i.value;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Parameter,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Parameter";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.formula, (v) => d.formula = v);
        ifPresent(this.isInputParameter, (v) => d.isInputParameter = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameterScope, (v) => d.parameterScope = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.uncertainty, (v) => d.uncertainty = v?.toDict());
        ifPresent(this.value, (v) => d.value = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Parameter();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.formula = d.formula;
        e.isInputParameter = d.isInputParameter;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.parameterScope = d.parameterScope;
        e.tags = d.tags;
        e.uncertainty = Uncertainty.fromDict(d.uncertainty);
        e.value = d.value;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Parameter.fromDict(JSON.parse(json))
            : Parameter.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Parameter = Parameter;
class ParameterRedef {
    constructor() {
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isProtected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "uncertainty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ParameterRedef();
        e.context = i.context;
        e.description = i.description;
        e.isProtected = i.isProtected;
        e.name = i.name;
        e.uncertainty = i.uncertainty;
        e.value = i.value;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.context, (v) => d.context = v?.toDict());
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.isProtected, (v) => d.isProtected = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.uncertainty, (v) => d.uncertainty = v?.toDict());
        ifPresent(this.value, (v) => d.value = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ParameterRedef();
        e.context = Ref.fromDict(d.context);
        e.description = d.description;
        e.isProtected = d.isProtected;
        e.name = d.name;
        e.uncertainty = Uncertainty.fromDict(d.uncertainty);
        e.value = d.value;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ParameterRedef.fromDict(JSON.parse(json))
            : ParameterRedef.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ParameterRedef = ParameterRedef;
class ParameterRedefSet {
    constructor() {
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isBaseline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ParameterRedefSet();
        e.description = i.description;
        e.isBaseline = i.isBaseline;
        e.name = i.name;
        e.parameters = i.parameters;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.isBaseline, (v) => d.isBaseline = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameters, (v) => d.parameters = dictAll(v));
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ParameterRedefSet();
        e.description = d.description;
        e.isBaseline = d.isBaseline;
        e.name = d.name;
        e.parameters = d.parameters
            ? d.parameters.map(ParameterRedef.fromDict)
            : null;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ParameterRedefSet.fromDict(JSON.parse(json))
            : ParameterRedefSet.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ParameterRedefSet = ParameterRedefSet;
class Process {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allocationFactors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultAllocationMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dqEntry", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dqSystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exchangeDqSystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exchanges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInfrastructureProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastInternalId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processDocumentation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "socialAspects", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "socialDqSystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Process();
        e.id = i.id;
        e.allocationFactors = i.allocationFactors;
        e.category = i.category;
        e.defaultAllocationMethod = i.defaultAllocationMethod;
        e.description = i.description;
        e.dqEntry = i.dqEntry;
        e.dqSystem = i.dqSystem;
        e.exchangeDqSystem = i.exchangeDqSystem;
        e.exchanges = i.exchanges;
        e.isInfrastructureProcess = i.isInfrastructureProcess;
        e.lastChange = i.lastChange;
        e.lastInternalId = i.lastInternalId;
        e.location = i.location;
        e.name = i.name;
        e.parameters = i.parameters;
        e.processDocumentation = i.processDocumentation;
        e.processType = i.processType;
        e.socialAspects = i.socialAspects;
        e.socialDqSystem = i.socialDqSystem;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Process,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Process";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.allocationFactors, (v) => d.allocationFactors = dictAll(v));
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.defaultAllocationMethod, (v) => d.defaultAllocationMethod = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.dqEntry, (v) => d.dqEntry = v);
        ifPresent(this.dqSystem, (v) => d.dqSystem = v?.toDict());
        ifPresent(this.exchangeDqSystem, (v) => d.exchangeDqSystem = v?.toDict());
        ifPresent(this.exchanges, (v) => d.exchanges = dictAll(v));
        ifPresent(this.isInfrastructureProcess, (v) => d.isInfrastructureProcess = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.lastInternalId, (v) => d.lastInternalId = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameters, (v) => d.parameters = dictAll(v));
        ifPresent(this.processDocumentation, (v) => d.processDocumentation = v?.toDict());
        ifPresent(this.processType, (v) => d.processType = v);
        ifPresent(this.socialAspects, (v) => d.socialAspects = dictAll(v));
        ifPresent(this.socialDqSystem, (v) => d.socialDqSystem = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Process();
        e.id = d["@id"];
        e.allocationFactors = d.allocationFactors
            ? d.allocationFactors.map(AllocationFactor.fromDict)
            : null;
        e.category = d.category;
        e.defaultAllocationMethod = d.defaultAllocationMethod;
        e.description = d.description;
        e.dqEntry = d.dqEntry;
        e.dqSystem = Ref.fromDict(d.dqSystem);
        e.exchangeDqSystem = Ref.fromDict(d.exchangeDqSystem);
        e.exchanges = d.exchanges
            ? d.exchanges.map(Exchange.fromDict)
            : null;
        e.isInfrastructureProcess = d.isInfrastructureProcess;
        e.lastChange = d.lastChange;
        e.lastInternalId = d.lastInternalId;
        e.location = Ref.fromDict(d.location);
        e.name = d.name;
        e.parameters = d.parameters
            ? d.parameters.map(Parameter.fromDict)
            : null;
        e.processDocumentation = ProcessDocumentation.fromDict(d.processDocumentation);
        e.processType = d.processType;
        e.socialAspects = d.socialAspects
            ? d.socialAspects.map(SocialAspect.fromDict)
            : null;
        e.socialDqSystem = Ref.fromDict(d.socialDqSystem);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Process.fromDict(JSON.parse(json))
            : Process.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Process = Process;
class ProcessDocumentation {
    constructor() {
        Object.defineProperty(this, "completenessDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "complianceDeclarations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "creationDate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataCollectionDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataDocumentor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataGenerator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataSelectionDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataSetOwner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dataTreatmentDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowCompleteness", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "geographyDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "intendedApplication", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inventoryMethodDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isCopyrightProtected", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modelingConstantsDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "projectDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "publication", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "restrictionsDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reviews", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "samplingDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sources", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "technologyDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeDescription", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "useAdvice", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validFrom", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validUntil", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ProcessDocumentation();
        e.completenessDescription = i.completenessDescription;
        e.complianceDeclarations = i.complianceDeclarations;
        e.creationDate = i.creationDate;
        e.dataCollectionDescription = i.dataCollectionDescription;
        e.dataDocumentor = i.dataDocumentor;
        e.dataGenerator = i.dataGenerator;
        e.dataSelectionDescription = i.dataSelectionDescription;
        e.dataSetOwner = i.dataSetOwner;
        e.dataTreatmentDescription = i.dataTreatmentDescription;
        e.flowCompleteness = i.flowCompleteness;
        e.geographyDescription = i.geographyDescription;
        e.intendedApplication = i.intendedApplication;
        e.inventoryMethodDescription = i.inventoryMethodDescription;
        e.isCopyrightProtected = i.isCopyrightProtected;
        e.modelingConstantsDescription = i.modelingConstantsDescription;
        e.projectDescription = i.projectDescription;
        e.publication = i.publication;
        e.restrictionsDescription = i.restrictionsDescription;
        e.reviews = i.reviews;
        e.samplingDescription = i.samplingDescription;
        e.sources = i.sources;
        e.technologyDescription = i.technologyDescription;
        e.timeDescription = i.timeDescription;
        e.useAdvice = i.useAdvice;
        e.validFrom = i.validFrom;
        e.validUntil = i.validUntil;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.completenessDescription, (v) => d.completenessDescription = v);
        ifPresent(this.complianceDeclarations, (v) => d.complianceDeclarations = dictAll(v));
        ifPresent(this.creationDate, (v) => d.creationDate = v);
        ifPresent(this.dataCollectionDescription, (v) => d.dataCollectionDescription = v);
        ifPresent(this.dataDocumentor, (v) => d.dataDocumentor = v?.toDict());
        ifPresent(this.dataGenerator, (v) => d.dataGenerator = v?.toDict());
        ifPresent(this.dataSelectionDescription, (v) => d.dataSelectionDescription = v);
        ifPresent(this.dataSetOwner, (v) => d.dataSetOwner = v?.toDict());
        ifPresent(this.dataTreatmentDescription, (v) => d.dataTreatmentDescription = v);
        ifPresent(this.flowCompleteness, (v) => d.flowCompleteness = dictAll(v));
        ifPresent(this.geographyDescription, (v) => d.geographyDescription = v);
        ifPresent(this.intendedApplication, (v) => d.intendedApplication = v);
        ifPresent(this.inventoryMethodDescription, (v) => d.inventoryMethodDescription = v);
        ifPresent(this.isCopyrightProtected, (v) => d.isCopyrightProtected = v);
        ifPresent(this.modelingConstantsDescription, (v) => d.modelingConstantsDescription = v);
        ifPresent(this.projectDescription, (v) => d.projectDescription = v);
        ifPresent(this.publication, (v) => d.publication = v?.toDict());
        ifPresent(this.restrictionsDescription, (v) => d.restrictionsDescription = v);
        ifPresent(this.reviews, (v) => d.reviews = dictAll(v));
        ifPresent(this.samplingDescription, (v) => d.samplingDescription = v);
        ifPresent(this.sources, (v) => d.sources = dictAll(v));
        ifPresent(this.technologyDescription, (v) => d.technologyDescription = v);
        ifPresent(this.timeDescription, (v) => d.timeDescription = v);
        ifPresent(this.useAdvice, (v) => d.useAdvice = v);
        ifPresent(this.validFrom, (v) => d.validFrom = v);
        ifPresent(this.validUntil, (v) => d.validUntil = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ProcessDocumentation();
        e.completenessDescription = d.completenessDescription;
        e.complianceDeclarations = d.complianceDeclarations
            ? d.complianceDeclarations.map(ComplianceDeclaration.fromDict)
            : null;
        e.creationDate = d.creationDate;
        e.dataCollectionDescription = d.dataCollectionDescription;
        e.dataDocumentor = Ref.fromDict(d.dataDocumentor);
        e.dataGenerator = Ref.fromDict(d.dataGenerator);
        e.dataSelectionDescription = d.dataSelectionDescription;
        e.dataSetOwner = Ref.fromDict(d.dataSetOwner);
        e.dataTreatmentDescription = d.dataTreatmentDescription;
        e.flowCompleteness = d.flowCompleteness
            ? d.flowCompleteness.map(AspectValue.fromDict)
            : null;
        e.geographyDescription = d.geographyDescription;
        e.intendedApplication = d.intendedApplication;
        e.inventoryMethodDescription = d.inventoryMethodDescription;
        e.isCopyrightProtected = d.isCopyrightProtected;
        e.modelingConstantsDescription = d.modelingConstantsDescription;
        e.projectDescription = d.projectDescription;
        e.publication = Ref.fromDict(d.publication);
        e.restrictionsDescription = d.restrictionsDescription;
        e.reviews = d.reviews
            ? d.reviews.map(Review.fromDict)
            : null;
        e.samplingDescription = d.samplingDescription;
        e.sources = d.sources
            ? d.sources.map(Ref.fromDict)
            : null;
        e.technologyDescription = d.technologyDescription;
        e.timeDescription = d.timeDescription;
        e.useAdvice = d.useAdvice;
        e.validFrom = d.validFrom;
        e.validUntil = d.validUntil;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ProcessDocumentation.fromDict(JSON.parse(json))
            : ProcessDocumentation.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ProcessDocumentation = ProcessDocumentation;
class ProcessLink {
    constructor() {
        Object.defineProperty(this, "exchange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "process", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ProcessLink();
        e.exchange = i.exchange;
        e.flow = i.flow;
        e.process = i.process;
        e.provider = i.provider;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.exchange, (v) => d.exchange = v?.toDict());
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.process, (v) => d.process = v?.toDict());
        ifPresent(this.provider, (v) => d.provider = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ProcessLink();
        e.exchange = ExchangeRef.fromDict(d.exchange);
        e.flow = Ref.fromDict(d.flow);
        e.process = Ref.fromDict(d.process);
        e.provider = Ref.fromDict(d.provider);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ProcessLink.fromDict(JSON.parse(json))
            : ProcessLink.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ProcessLink = ProcessLink;
class ProductSystem {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameterSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processLinks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refExchange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refProcess", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "targetAmount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "targetFlowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "targetUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ProductSystem();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.parameterSets = i.parameterSets;
        e.processLinks = i.processLinks;
        e.processes = i.processes;
        e.refExchange = i.refExchange;
        e.refProcess = i.refProcess;
        e.tags = i.tags;
        e.targetAmount = i.targetAmount;
        e.targetFlowProperty = i.targetFlowProperty;
        e.targetUnit = i.targetUnit;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.ProductSystem,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "ProductSystem";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameterSets, (v) => d.parameterSets = dictAll(v));
        ifPresent(this.processLinks, (v) => d.processLinks = dictAll(v));
        ifPresent(this.processes, (v) => d.processes = dictAll(v));
        ifPresent(this.refExchange, (v) => d.refExchange = v?.toDict());
        ifPresent(this.refProcess, (v) => d.refProcess = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.targetAmount, (v) => d.targetAmount = v);
        ifPresent(this.targetFlowProperty, (v) => d.targetFlowProperty = v?.toDict());
        ifPresent(this.targetUnit, (v) => d.targetUnit = v?.toDict());
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ProductSystem();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.parameterSets = d.parameterSets
            ? d.parameterSets.map(ParameterRedefSet.fromDict)
            : null;
        e.processLinks = d.processLinks
            ? d.processLinks.map(ProcessLink.fromDict)
            : null;
        e.processes = d.processes
            ? d.processes.map(Ref.fromDict)
            : null;
        e.refExchange = ExchangeRef.fromDict(d.refExchange);
        e.refProcess = Ref.fromDict(d.refProcess);
        e.tags = d.tags;
        e.targetAmount = d.targetAmount;
        e.targetFlowProperty = Ref.fromDict(d.targetFlowProperty);
        e.targetUnit = Ref.fromDict(d.targetUnit);
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ProductSystem.fromDict(JSON.parse(json))
            : ProductSystem.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ProductSystem = ProductSystem;
class Project {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isWithCosts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isWithRegionalization", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nwSet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "variants", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Project();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.impactMethod = i.impactMethod;
        e.isWithCosts = i.isWithCosts;
        e.isWithRegionalization = i.isWithRegionalization;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.nwSet = i.nwSet;
        e.tags = i.tags;
        e.variants = i.variants;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Project,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Project";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.impactMethod, (v) => d.impactMethod = v?.toDict());
        ifPresent(this.isWithCosts, (v) => d.isWithCosts = v);
        ifPresent(this.isWithRegionalization, (v) => d.isWithRegionalization = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.nwSet, (v) => d.nwSet = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.variants, (v) => d.variants = dictAll(v));
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Project();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.impactMethod = Ref.fromDict(d.impactMethod);
        e.isWithCosts = d.isWithCosts;
        e.isWithRegionalization = d.isWithRegionalization;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.nwSet = NwSet.fromDict(d.nwSet);
        e.tags = d.tags;
        e.variants = d.variants
            ? d.variants.map(ProjectVariant.fromDict)
            : null;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Project.fromDict(JSON.parse(json))
            : Project.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Project = Project;
class ProjectVariant {
    constructor() {
        Object.defineProperty(this, "allocationMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isDisabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameterRedefs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "productSystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ProjectVariant();
        e.allocationMethod = i.allocationMethod;
        e.amount = i.amount;
        e.description = i.description;
        e.isDisabled = i.isDisabled;
        e.name = i.name;
        e.parameterRedefs = i.parameterRedefs;
        e.productSystem = i.productSystem;
        e.unit = i.unit;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.allocationMethod, (v) => d.allocationMethod = v);
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.isDisabled, (v) => d.isDisabled = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.parameterRedefs, (v) => d.parameterRedefs = dictAll(v));
        ifPresent(this.productSystem, (v) => d.productSystem = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ProjectVariant();
        e.allocationMethod = d.allocationMethod;
        e.amount = d.amount;
        e.description = d.description;
        e.isDisabled = d.isDisabled;
        e.name = d.name;
        e.parameterRedefs = d.parameterRedefs
            ? d.parameterRedefs.map(ParameterRedef.fromDict)
            : null;
        e.productSystem = Ref.fromDict(d.productSystem);
        e.unit = Ref.fromDict(d.unit);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ProjectVariant.fromDict(JSON.parse(json))
            : ProjectVariant.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ProjectVariant = ProjectVariant;
class Ref {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Ref();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.flowType = i.flowType;
        e.location = i.location;
        e.name = i.name;
        e.processType = i.processType;
        e.refUnit = i.refUnit;
        e.refType = i.refType;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.refType, (v) => d["@type"] = v);
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.flowType, (v) => d.flowType = v);
        ifPresent(this.location, (v) => d.location = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.processType, (v) => d.processType = v);
        ifPresent(this.refUnit, (v) => d.refUnit = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Ref();
        ifPresent(d["@type"], (v) => e.refType = v);
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.flowType = d.flowType;
        e.location = d.location;
        e.name = d.name;
        e.processType = d.processType;
        e.refUnit = d.refUnit;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Ref.fromDict(JSON.parse(json))
            : Ref.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Ref = Ref;
class Result {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowResults", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactResults", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "productSystem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Result();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.flowResults = i.flowResults;
        e.impactMethod = i.impactMethod;
        e.impactResults = i.impactResults;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.productSystem = i.productSystem;
        e.tags = i.tags;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Result,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Result";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.flowResults, (v) => d.flowResults = dictAll(v));
        ifPresent(this.impactMethod, (v) => d.impactMethod = v?.toDict());
        ifPresent(this.impactResults, (v) => d.impactResults = dictAll(v));
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.productSystem, (v) => d.productSystem = v?.toDict());
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Result();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.flowResults = d.flowResults
            ? d.flowResults.map(FlowResult.fromDict)
            : null;
        e.impactMethod = Ref.fromDict(d.impactMethod);
        e.impactResults = d.impactResults
            ? d.impactResults.map(ImpactResult.fromDict)
            : null;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.productSystem = Ref.fromDict(d.productSystem);
        e.tags = d.tags;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Result.fromDict(JSON.parse(json))
            : Result.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Result = Result;
class Review {
    constructor() {
        Object.defineProperty(this, "assessment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "report", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reviewType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reviewers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "scopes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Review();
        e.assessment = i.assessment;
        e.details = i.details;
        e.report = i.report;
        e.reviewType = i.reviewType;
        e.reviewers = i.reviewers;
        e.scopes = i.scopes;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.assessment, (v) => d.assessment = dictAll(v));
        ifPresent(this.details, (v) => d.details = v);
        ifPresent(this.report, (v) => d.report = v?.toDict());
        ifPresent(this.reviewType, (v) => d.reviewType = v);
        ifPresent(this.reviewers, (v) => d.reviewers = dictAll(v));
        ifPresent(this.scopes, (v) => d.scopes = dictAll(v));
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Review();
        e.assessment = d.assessment
            ? d.assessment.map(AspectValue.fromDict)
            : null;
        e.details = d.details;
        e.report = Ref.fromDict(d.report);
        e.reviewType = d.reviewType;
        e.reviewers = d.reviewers
            ? d.reviewers.map(Ref.fromDict)
            : null;
        e.scopes = d.scopes
            ? d.scopes.map(ReviewScope.fromDict)
            : null;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Review.fromDict(JSON.parse(json))
            : Review.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Review = Review;
class ReviewScope {
    constructor() {
        Object.defineProperty(this, "methods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ReviewScope();
        e.methods = i.methods;
        e.name = i.name;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.methods, (v) => d.methods = v);
        ifPresent(this.name, (v) => d.name = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ReviewScope();
        e.methods = d.methods;
        e.name = d.name;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ReviewScope.fromDict(JSON.parse(json))
            : ReviewScope.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ReviewScope = ReviewScope;
class SocialAspect {
    constructor() {
        Object.defineProperty(this, "activityValue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "comment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "quality", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rawAmount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "riskLevel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "socialIndicator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "source", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SocialAspect();
        e.activityValue = i.activityValue;
        e.comment = i.comment;
        e.quality = i.quality;
        e.rawAmount = i.rawAmount;
        e.riskLevel = i.riskLevel;
        e.socialIndicator = i.socialIndicator;
        e.source = i.source;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.activityValue, (v) => d.activityValue = v);
        ifPresent(this.comment, (v) => d.comment = v);
        ifPresent(this.quality, (v) => d.quality = v);
        ifPresent(this.rawAmount, (v) => d.rawAmount = v);
        ifPresent(this.riskLevel, (v) => d.riskLevel = v);
        ifPresent(this.socialIndicator, (v) => d.socialIndicator = v?.toDict());
        ifPresent(this.source, (v) => d.source = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SocialAspect();
        e.activityValue = d.activityValue;
        e.comment = d.comment;
        e.quality = d.quality;
        e.rawAmount = d.rawAmount;
        e.riskLevel = d.riskLevel;
        e.socialIndicator = Ref.fromDict(d.socialIndicator);
        e.source = Ref.fromDict(d.source);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SocialAspect.fromDict(JSON.parse(json))
            : SocialAspect.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SocialAspect = SocialAspect;
class SocialIndicator {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "activityQuantity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "activityUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "activityVariable", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "evaluationScheme", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unitOfMeasurement", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SocialIndicator();
        e.id = i.id;
        e.activityQuantity = i.activityQuantity;
        e.activityUnit = i.activityUnit;
        e.activityVariable = i.activityVariable;
        e.category = i.category;
        e.description = i.description;
        e.evaluationScheme = i.evaluationScheme;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.tags = i.tags;
        e.unitOfMeasurement = i.unitOfMeasurement;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.SocialIndicator,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "SocialIndicator";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.activityQuantity, (v) => d.activityQuantity = v?.toDict());
        ifPresent(this.activityUnit, (v) => d.activityUnit = v?.toDict());
        ifPresent(this.activityVariable, (v) => d.activityVariable = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.evaluationScheme, (v) => d.evaluationScheme = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.unitOfMeasurement, (v) => d.unitOfMeasurement = v);
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SocialIndicator();
        e.id = d["@id"];
        e.activityQuantity = Ref.fromDict(d.activityQuantity);
        e.activityUnit = Ref.fromDict(d.activityUnit);
        e.activityVariable = d.activityVariable;
        e.category = d.category;
        e.description = d.description;
        e.evaluationScheme = d.evaluationScheme;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.tags = d.tags;
        e.unitOfMeasurement = d.unitOfMeasurement;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SocialIndicator.fromDict(JSON.parse(json))
            : SocialIndicator.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SocialIndicator = SocialIndicator;
class Source {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "externalFile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textReference", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "year", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Source();
        e.id = i.id;
        e.category = i.category;
        e.description = i.description;
        e.externalFile = i.externalFile;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.tags = i.tags;
        e.textReference = i.textReference;
        e.url = i.url;
        e.version = i.version;
        e.year = i.year;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Source,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Source";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.externalFile, (v) => d.externalFile = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.textReference, (v) => d.textReference = v);
        ifPresent(this.url, (v) => d.url = v);
        ifPresent(this.version, (v) => d.version = v);
        ifPresent(this.year, (v) => d.year = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Source();
        e.id = d["@id"];
        e.category = d.category;
        e.description = d.description;
        e.externalFile = d.externalFile;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.tags = d.tags;
        e.textReference = d.textReference;
        e.url = d.url;
        e.version = d.version;
        e.year = d.year;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Source.fromDict(JSON.parse(json))
            : Source.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Source = Source;
class Uncertainty {
    constructor() {
        Object.defineProperty(this, "distributionType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "geomMean", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "geomSd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maximum", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mean", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minimum", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Uncertainty();
        e.distributionType = i.distributionType;
        e.geomMean = i.geomMean;
        e.geomSd = i.geomSd;
        e.maximum = i.maximum;
        e.mean = i.mean;
        e.minimum = i.minimum;
        e.mode = i.mode;
        e.sd = i.sd;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.distributionType, (v) => d.distributionType = v);
        ifPresent(this.geomMean, (v) => d.geomMean = v);
        ifPresent(this.geomSd, (v) => d.geomSd = v);
        ifPresent(this.maximum, (v) => d.maximum = v);
        ifPresent(this.mean, (v) => d.mean = v);
        ifPresent(this.minimum, (v) => d.minimum = v);
        ifPresent(this.mode, (v) => d.mode = v);
        ifPresent(this.sd, (v) => d.sd = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Uncertainty();
        e.distributionType = d.distributionType;
        e.geomMean = d.geomMean;
        e.geomSd = d.geomSd;
        e.maximum = d.maximum;
        e.mean = d.mean;
        e.minimum = d.minimum;
        e.mode = d.mode;
        e.sd = d.sd;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Uncertainty.fromDict(JSON.parse(json))
            : Uncertainty.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Uncertainty = Uncertainty;
class Unit {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "conversionFactor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isRefUnit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "synonyms", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new Unit();
        e.id = i.id;
        e.conversionFactor = i.conversionFactor;
        e.description = i.description;
        e.isRefUnit = i.isRefUnit;
        e.name = i.name;
        e.synonyms = i.synonyms;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.Unit,
            id: this.id,
            name: this.name,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "Unit";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.conversionFactor, (v) => d.conversionFactor = v);
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.isRefUnit, (v) => d.isRefUnit = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.synonyms, (v) => d.synonyms = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new Unit();
        e.id = d["@id"];
        e.conversionFactor = d.conversionFactor;
        e.description = d.description;
        e.isRefUnit = d.isRefUnit;
        e.name = d.name;
        e.synonyms = d.synonyms;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? Unit.fromDict(JSON.parse(json))
            : Unit.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.Unit = Unit;
class UnitGroup {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "category", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "defaultFlowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "description", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastChange", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "units", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new UnitGroup();
        e.id = i.id;
        e.category = i.category;
        e.defaultFlowProperty = i.defaultFlowProperty;
        e.description = i.description;
        e.lastChange = i.lastChange;
        e.name = i.name;
        e.tags = i.tags;
        e.units = i.units;
        e.version = i.version;
        return e;
    }
    toRef() {
        return Ref.of({
            refType: RefType.UnitGroup,
            id: this.id,
            name: this.name,
            category: this.category,
        });
    }
    toDict() {
        const d = {};
        d["@type"] = "UnitGroup";
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.category, (v) => d.category = v);
        ifPresent(this.defaultFlowProperty, (v) => d.defaultFlowProperty = v?.toDict());
        ifPresent(this.description, (v) => d.description = v);
        ifPresent(this.lastChange, (v) => d.lastChange = v);
        ifPresent(this.name, (v) => d.name = v);
        ifPresent(this.tags, (v) => d.tags = v);
        ifPresent(this.units, (v) => d.units = dictAll(v));
        ifPresent(this.version, (v) => d.version = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new UnitGroup();
        e.id = d["@id"];
        e.category = d.category;
        e.defaultFlowProperty = Ref.fromDict(d.defaultFlowProperty);
        e.description = d.description;
        e.lastChange = d.lastChange;
        e.name = d.name;
        e.tags = d.tags;
        e.units = d.units ? d.units.map(Unit.fromDict) : null;
        e.version = d.version;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? UnitGroup.fromDict(JSON.parse(json))
            : UnitGroup.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.UnitGroup = UnitGroup;
class CalculationSetup {
    constructor() {
        Object.defineProperty(this, "allocation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "flowProperty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactMethod", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nwSet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "parameters", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "unit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "withCosts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "withRegionalization", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new CalculationSetup();
        e.allocation = i.allocation;
        e.amount = i.amount;
        e.flowProperty = i.flowProperty;
        e.impactMethod = i.impactMethod;
        e.nwSet = i.nwSet;
        e.parameters = i.parameters;
        e.target = i.target;
        e.unit = i.unit;
        e.withCosts = i.withCosts;
        e.withRegionalization = i.withRegionalization;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.allocation, (v) => d.allocation = v);
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.flowProperty, (v) => d.flowProperty = v?.toDict());
        ifPresent(this.impactMethod, (v) => d.impactMethod = v?.toDict());
        ifPresent(this.nwSet, (v) => d.nwSet = v?.toDict());
        ifPresent(this.parameters, (v) => d.parameters = dictAll(v));
        ifPresent(this.target, (v) => d.target = v?.toDict());
        ifPresent(this.unit, (v) => d.unit = v?.toDict());
        ifPresent(this.withCosts, (v) => d.withCosts = v);
        ifPresent(this.withRegionalization, (v) => d.withRegionalization = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new CalculationSetup();
        e.allocation = d.allocation;
        e.amount = d.amount;
        e.flowProperty = Ref.fromDict(d.flowProperty);
        e.impactMethod = Ref.fromDict(d.impactMethod);
        e.nwSet = Ref.fromDict(d.nwSet);
        e.parameters = d.parameters
            ? d.parameters.map(ParameterRedef.fromDict)
            : null;
        e.target = Ref.fromDict(d.target);
        e.unit = Ref.fromDict(d.unit);
        e.withCosts = d.withCosts;
        e.withRegionalization = d.withRegionalization;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? CalculationSetup.fromDict(JSON.parse(json))
            : CalculationSetup.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.CalculationSetup = CalculationSetup;
class CostValue {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "currency", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new CostValue();
        e.amount = i.amount;
        e.currency = i.currency;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.currency, (v) => d.currency = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new CostValue();
        e.amount = d.amount;
        e.currency = Ref.fromDict(d.currency);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? CostValue.fromDict(JSON.parse(json))
            : CostValue.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.CostValue = CostValue;
class EnviFlow {
    constructor() {
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new EnviFlow();
        e.flow = i.flow;
        e.isInput = i.isInput;
        e.location = i.location;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.isInput, (v) => d.isInput = v);
        ifPresent(this.location, (v) => d.location = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new EnviFlow();
        e.flow = Ref.fromDict(d.flow);
        e.isInput = d.isInput;
        e.location = Ref.fromDict(d.location);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? EnviFlow.fromDict(JSON.parse(json))
            : EnviFlow.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.EnviFlow = EnviFlow;
class EnviFlowValue {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "enviFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new EnviFlowValue();
        e.amount = i.amount;
        e.enviFlow = i.enviFlow;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.enviFlow, (v) => d.enviFlow = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new EnviFlowValue();
        e.amount = d.amount;
        e.enviFlow = EnviFlow.fromDict(d.enviFlow);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? EnviFlowValue.fromDict(JSON.parse(json))
            : EnviFlowValue.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.EnviFlowValue = EnviFlowValue;
class ImpactValue {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactCategory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ImpactValue();
        e.amount = i.amount;
        e.impactCategory = i.impactCategory;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.impactCategory, (v) => d.impactCategory = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ImpactValue();
        e.amount = d.amount;
        e.impactCategory = Ref.fromDict(d.impactCategory);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ImpactValue.fromDict(JSON.parse(json))
            : ImpactValue.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ImpactValue = ImpactValue;
class ResultState {
    constructor() {
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isScheduled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "time", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new ResultState();
        e.id = i.id;
        e.error = i.error;
        e.isReady = i.isReady;
        e.isScheduled = i.isScheduled;
        e.time = i.time;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.id, (v) => d["@id"] = v);
        ifPresent(this.error, (v) => d.error = v);
        ifPresent(this.isReady, (v) => d.isReady = v);
        ifPresent(this.isScheduled, (v) => d.isScheduled = v);
        ifPresent(this.time, (v) => d.time = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new ResultState();
        e.id = d["@id"];
        e.error = d.error;
        e.isReady = d.isReady;
        e.isScheduled = d.isScheduled;
        e.time = d.time;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? ResultState.fromDict(JSON.parse(json))
            : ResultState.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.ResultState = ResultState;
class SankeyEdge {
    constructor() {
        Object.defineProperty(this, "nodeIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "providerIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "upstreamShare", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SankeyEdge();
        e.nodeIndex = i.nodeIndex;
        e.providerIndex = i.providerIndex;
        e.upstreamShare = i.upstreamShare;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.nodeIndex, (v) => d.nodeIndex = v);
        ifPresent(this.providerIndex, (v) => d.providerIndex = v);
        ifPresent(this.upstreamShare, (v) => d.upstreamShare = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SankeyEdge();
        e.nodeIndex = d.nodeIndex;
        e.providerIndex = d.providerIndex;
        e.upstreamShare = d.upstreamShare;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SankeyEdge.fromDict(JSON.parse(json))
            : SankeyEdge.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SankeyEdge = SankeyEdge;
class SankeyGraph {
    constructor() {
        Object.defineProperty(this, "edges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nodes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "rootIndex", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SankeyGraph();
        e.edges = i.edges;
        e.nodes = i.nodes;
        e.rootIndex = i.rootIndex;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.edges, (v) => d.edges = dictAll(v));
        ifPresent(this.nodes, (v) => d.nodes = dictAll(v));
        ifPresent(this.rootIndex, (v) => d.rootIndex = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SankeyGraph();
        e.edges = d.edges
            ? d.edges.map(SankeyEdge.fromDict)
            : null;
        e.nodes = d.nodes
            ? d.nodes.map(SankeyNode.fromDict)
            : null;
        e.rootIndex = d.rootIndex;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SankeyGraph.fromDict(JSON.parse(json))
            : SankeyGraph.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SankeyGraph = SankeyGraph;
class SankeyNode {
    constructor() {
        Object.defineProperty(this, "directResult", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "techFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "totalResult", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SankeyNode();
        e.directResult = i.directResult;
        e.index = i.index;
        e.techFlow = i.techFlow;
        e.totalResult = i.totalResult;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.directResult, (v) => d.directResult = v);
        ifPresent(this.index, (v) => d.index = v);
        ifPresent(this.techFlow, (v) => d.techFlow = v?.toDict());
        ifPresent(this.totalResult, (v) => d.totalResult = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SankeyNode();
        e.directResult = d.directResult;
        e.index = d.index;
        e.techFlow = TechFlow.fromDict(d.techFlow);
        e.totalResult = d.totalResult;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SankeyNode.fromDict(JSON.parse(json))
            : SankeyNode.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SankeyNode = SankeyNode;
class SankeyRequest {
    constructor() {
        Object.defineProperty(this, "enviFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "forCosts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "impactCategory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "maxNodes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minShare", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new SankeyRequest();
        e.enviFlow = i.enviFlow;
        e.forCosts = i.forCosts;
        e.impactCategory = i.impactCategory;
        e.maxNodes = i.maxNodes;
        e.minShare = i.minShare;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.enviFlow, (v) => d.enviFlow = v?.toDict());
        ifPresent(this.forCosts, (v) => d.forCosts = v);
        ifPresent(this.impactCategory, (v) => d.impactCategory = v?.toDict());
        ifPresent(this.maxNodes, (v) => d.maxNodes = v);
        ifPresent(this.minShare, (v) => d.minShare = v);
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new SankeyRequest();
        e.enviFlow = EnviFlow.fromDict(d.enviFlow);
        e.forCosts = d.forCosts;
        e.impactCategory = Ref.fromDict(d.impactCategory);
        e.maxNodes = d.maxNodes;
        e.minShare = d.minShare;
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? SankeyRequest.fromDict(JSON.parse(json))
            : SankeyRequest.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.SankeyRequest = SankeyRequest;
class TechFlow {
    constructor() {
        Object.defineProperty(this, "flow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new TechFlow();
        e.flow = i.flow;
        e.provider = i.provider;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.flow, (v) => d.flow = v?.toDict());
        ifPresent(this.provider, (v) => d.provider = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new TechFlow();
        e.flow = Ref.fromDict(d.flow);
        e.provider = Ref.fromDict(d.provider);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? TechFlow.fromDict(JSON.parse(json))
            : TechFlow.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.TechFlow = TechFlow;
class TechFlowValue {
    constructor() {
        Object.defineProperty(this, "amount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "techFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new TechFlowValue();
        e.amount = i.amount;
        e.techFlow = i.techFlow;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.amount, (v) => d.amount = v);
        ifPresent(this.techFlow, (v) => d.techFlow = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new TechFlowValue();
        e.amount = d.amount;
        e.techFlow = TechFlow.fromDict(d.techFlow);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? TechFlowValue.fromDict(JSON.parse(json))
            : TechFlowValue.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.TechFlowValue = TechFlowValue;
class UpstreamNode {
    constructor() {
        Object.defineProperty(this, "directContribution", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "requiredAmount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "techFlow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    static of(i) {
        const e = new UpstreamNode();
        e.directContribution = i.directContribution;
        e.requiredAmount = i.requiredAmount;
        e.result = i.result;
        e.techFlow = i.techFlow;
        return e;
    }
    toDict() {
        const d = {};
        ifPresent(this.directContribution, (v) => d.directContribution = v);
        ifPresent(this.requiredAmount, (v) => d.requiredAmount = v);
        ifPresent(this.result, (v) => d.result = v);
        ifPresent(this.techFlow, (v) => d.techFlow = v?.toDict());
        return d;
    }
    static fromDict(d) {
        if (!d)
            return null;
        const e = new UpstreamNode();
        e.directContribution = d.directContribution;
        e.requiredAmount = d.requiredAmount;
        e.result = d.result;
        e.techFlow = TechFlow.fromDict(d.techFlow);
        return e;
    }
    static fromJson(json) {
        return typeof json === "string"
            ? UpstreamNode.fromDict(JSON.parse(json))
            : UpstreamNode.fromDict(json);
    }
    toJson() {
        return JSON.stringify(this.toDict(), null, "  ");
    }
}
exports.UpstreamNode = UpstreamNode;
